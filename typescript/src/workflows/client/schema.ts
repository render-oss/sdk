/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/blueprints': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Blueprints
     * @description List Blueprints for the specified workspaces. If no workspaces are provided, returns all Blueprints the API key has access to.
     */
    get: operations['list-blueprints'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/blueprints/{blueprintId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the Blueprint */
        blueprintId: components['parameters']['blueprintId'];
      };
      cookie?: never;
    };
    /**
     * Retrieve Blueprint
     * @description Retrieve the Blueprint with the provided ID.
     */
    get: operations['retrieve-blueprint'];
    put?: never;
    post?: never;
    /**
     * Disconnect Blueprint
     * @description Disconnect the Blueprint with the provided ID.
     *
     *     Disconnecting a Blueprint stops automatic resource syncing via the associated `render.yaml` file. It does not _delete_ any services or other resources that were managed by the blueprint.
     */
    delete: operations['disconnect-blueprint'];
    options?: never;
    head?: never;
    /**
     * Update Blueprint
     * @description Update the Blueprint with the provided ID.
     */
    patch: operations['update-blueprint'];
    trace?: never;
  };
  '/blueprints/{blueprintId}/syncs': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the Blueprint */
        blueprintId: components['parameters']['blueprintId'];
      };
      cookie?: never;
    };
    /**
     * List Blueprint syncs
     * @description List syncs for the Blueprint with the provided ID.
     */
    get: operations['list-blueprint-syncs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/disks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List disks
     * @description List persistent disks matching the provided filters. If no filters are provided, returns all disks you have permissions to view.
     */
    get: operations['list-disks'];
    put?: never;
    /**
     * Add disk
     * @description Attach a persistent disk to a web service, private service, or background worker.
     *
     *     The service must be redeployed for the disk to be attached.
     */
    post: operations['add-disk'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/disks/{diskId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: components['parameters']['diskId'];
      };
      cookie?: never;
    };
    /**
     * Retrieve disk
     * @description Retrieve the persistent disk with the provided ID.
     */
    get: operations['retrieve-disk'];
    put?: never;
    post?: never;
    /**
     * Delete disk
     * @description Delete a persistent disk attached to a service.
     *
     *     **All data on the disk will be lost.** The disk's associated service will immediately lose access to it.
     */
    delete: operations['delete-disk'];
    options?: never;
    head?: never;
    /**
     * Update disk
     * @description Update the persistent disk with the provided ID.
     *
     *     The disk's associated service must be deployed and active for updates to take effect.
     *
     *     When resizing a disk, the new size must be greater than the current size.
     */
    patch: operations['update-disk'];
    trace?: never;
  };
  '/disks/{diskId}/snapshots': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: string;
      };
      cookie?: never;
    };
    /**
     * List snapshots
     * @description List snapshots for the persistent disk with the provided ID. Each snapshot is a point-in-time copy of the disk's data.
     */
    get: operations['list-snapshots'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/disks/{diskId}/snapshots/restore': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore snapshot
     * @description Restore a persistent disk to an available snapshot.
     *
     *     **This operation is irreversible.** It will overwrite the current disk data. It might also trigger a service deploy.
     *
     *     Snapshot keys returned from the [List snapshots](https://api-docs.render.com/reference/list-snapshots) endpoint expire after 24 hours. If a snapshot key has expired, query the endpoint again for a new key.
     */
    post: operations['restore-snapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get the authenticated user
     * @description Retrieve the user associated with the provided API key.
     */
    get: operations['get-user'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/owners': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List workspaces
     * @description List the workspaces that your API key has access to, optionally filtered by name or owner email address.
     */
    get: operations['list-owners'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/owners/{ownerId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the user or team */
        ownerId: string;
      };
      cookie?: never;
    };
    /**
     * Retrieve workspace
     * @description Retrieve the workspace with the provided ID.
     *
     *     Workspace IDs start with `tea-`. If you provide a user ID (starts with `own-`), this endpoint returns the user's default workspace.
     */
    get: operations['retrieve-owner'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/owners/{ownerId}/members': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the team */
        ownerId: string;
      };
      cookie?: never;
    };
    /**
     * List workspace members
     * @description Retrieves the list of users belonging to the workspace with the provided ID.
     */
    get: operations['retrieve-owner-members'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/owners/{ownerId}/audit-logs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return resources for */
        ownerId: components['parameters']['ownerIdPathParam'];
      };
      cookie?: never;
    };
    /**
     * List workspace audit logs
     * @description Retrieve audit logs for a specific workspace with optional filtering and pagination.
     */
    get: operations['list-owner-audit-logs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/organizations/{orgId}/audit-logs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of the organization */
        orgId: string;
      };
      cookie?: never;
    };
    /**
     * List organization audit logs
     * @description Retrieve audit logs for a specific organization with optional filtering and pagination.
     */
    get: operations['list-organization-audit-logs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification-settings/owners/{ownerId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return resources for */
        ownerId: components['parameters']['ownerIdPathParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve notification settings
     * @description Retrieve notification settings for the owner with the provided ID.
     *
     *     Note that you provide an owner ID to this endpoint, not the ID for a particular resource.
     */
    get: operations['retrieve-owner-notification-settings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update notification settings
     * @description Update notification settings for the owner with the provided ID.
     */
    patch: operations['patch-owner-notification-settings'];
    trace?: never;
  };
  '/notification-settings/overrides': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List notification overrides
     * @description List notification overrides matching the provided filters. If no filters are provided, returns all notification overrides for all workspaces the user belongs to.
     */
    get: operations['list-notification-overrides'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification-settings/overrides/services/{serviceId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve notification override
     * @description Retrieve the notification override for the service with the provided ID.
     *
     *     Note that you provide a service ID to this endpoint, not the ID for a particular override.
     */
    get: operations['retrieve-service-notification-overrides'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update notification override
     * @description Update the notification override for the service with the provided ID.
     */
    patch: operations['patch-service-notification-overrides'];
    trace?: never;
  };
  '/registrycredentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List registry credentials
     * @description List registry credentials matching the provided filters. If no filters are provided, returns all registry credentials you have permissions to view.
     */
    get: operations['list-registry-credentials'];
    put?: never;
    /**
     * Create registry credential
     * @description Create a new registry credential.
     */
    post: operations['create-registry-credential'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/registrycredentials/{registryCredentialId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the registry credential */
        registryCredentialId: string;
      };
      cookie?: never;
    };
    /**
     * Retrieve registry credential
     * @description Retrieve the registry credential with the provided ID.
     */
    get: operations['retrieve-registry-credential'];
    put?: never;
    post?: never;
    /**
     * Delete registry credential
     * @description Delete the registry credential with the provided ID.
     */
    delete: operations['delete-registry-credential'];
    options?: never;
    head?: never;
    /**
     * Update registry credential
     * @description Update the registry credential with the provided ID. Services that use this credential must be redeployed to use updated values.
     */
    patch: operations['update-registry-credential'];
    trace?: never;
  };
  '/services': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List services
     * @description List services matching the provided filters. If no filters are provided, returns all services you have permissions to view.
     */
    get: operations['list-services'];
    put?: never;
    /**
     * Create service
     * @description Create a service.
     */
    post: operations['create-service'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve service
     * @description Retrieve the service with the provided ID.
     */
    get: operations['retrieve-service'];
    put?: never;
    post?: never;
    /**
     * Delete service
     * @description Delete the service with the provided ID.
     */
    delete: operations['delete-service'];
    options?: never;
    head?: never;
    /**
     * Update service
     * @description Update the service with the provided ID.
     */
    patch: operations['update-service'];
    trace?: never;
  };
  '/services/{serviceId}/cache/purge': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Purge Web Service Cache
     * @description Trigger cache purge for the web service if caching is enabled.
     */
    post: operations['purge-cache'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/deploys': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List deploys
     * @description List deploys matching the provided filters. If no filters are provided, all deploys for the service are returned.
     */
    get: operations['list-deploys'];
    put?: never;
    /**
     * Trigger deploy
     * @description Trigger a deploy for the service with the provided ID.
     */
    post: operations['create-deploy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/deploys/{deployId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the deploy */
        deployId: components['parameters']['deployIdParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve deploy
     * @description Retrieve the details of a particular deploy for a particular service.
     */
    get: operations['retrieve-deploy'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/deploys/{deployId}/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the deploy */
        deployId: components['parameters']['deployIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel deploy
     * @description Cancel an in-progress deploy for a service.
     *
     *     Not supported for cron jobs.
     */
    post: operations['cancel-deploy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/rollback': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Roll back deploy
     * @description Trigger a rollback to a previous deploy of the specified service.
     *
     *     Triggering a rollback with this endpoint does not disable autodeploys for the service. This means an autodeploy might restore changes you had intentionally rolled back.
     *
     *     You can toggle autodeploys for your service with the [Update service](https://api-docs.render.com/reference/update-service) endpoint or in the Render Dashboard.
     */
    post: operations['rollback-deploy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/env-vars': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List environment variables
     * @description List all environment variables for the service with the provided ID.
     */
    get: operations['get-env-vars-for-service'];
    /**
     * Update environment variables
     * @description Replace all environment variables for a service with the provided list of environment variables.
     */
    put: operations['update-env-vars-for-service'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/env-vars/{envVarKey}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve environment variable
     * @description Retrieve a particular environment variable for a particular service.
     *
     *     This only applies to environment variables set directly on the service, not to environment variables in a linked environment group.
     */
    get: operations['retrieve-env-var'];
    /**
     * Add or update environment variable
     * @description Add or update a particular environment variable for a particular service.
     *
     *     This only applies to environment variables set directly on the service, not to environment variables in a linked environment group.
     */
    put: operations['update-env-var'];
    post?: never;
    /**
     * Delete environment variable
     * @description Delete a particular environment variable from a particular service.
     *
     *     This only applies to environment variables set directly on the service, not to environment variables in a linked environment group.
     */
    delete: operations['delete-env-var'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/secret-files': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List secret files
     * @description List all secret files for the service with the provided ID.
     */
    get: operations['list-secret-files-for-service'];
    /**
     * Update secret files
     * @description Replace all secret files for a service with the provided list of secret files.
     *
     *     **Any of the service's existing secret files not included in this request will be deleted.**
     *
     *     This only applies to secret files set directly on the service, not to secret files in a linked environment group.
     */
    put: operations['update-secret-files-for-service'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/secret-files/{secretFileName}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The file name of the secret file */
        secretFileName: string;
      };
      cookie?: never;
    };
    /**
     * Retrieve secret file
     * @description Retrieve a particular secret file for a particular service.
     *
     *     This only applies to secret files set directly on the service, not to secret files in a linked environment group.
     */
    get: operations['retrieve-secret-file'];
    /**
     * Add or update secret file
     * @description Add or update a particular secret file for a particular service.
     *
     *     This only applies to secret files set directly on the service, not to secret files in a linked environment group.
     */
    put: operations['add-or-update-secret-file'];
    post?: never;
    /**
     * Delete secret file
     * @description Delete a particular secret file from a particular service.
     *
     *     This only applies to secret files set directly on the service, not to secret files in a linked environment group.
     */
    delete: operations['delete-secret-file'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List events
     * @description List recent events that occurred for the service with the provided ID.
     */
    get: operations['list-events'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/headers': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List header rules
     * @description List a particular service's response header rules that match the provided filters. If no filters are provided, all rules for the service are returned.
     */
    get: operations['list-headers'];
    /**
     * Replace header rules
     * @description Replace all header rules for a particular service with the provided list.
     *
     *     **This deletes all existing header rules for the service that aren't included in the request.**
     */
    put: operations['update-headers'];
    /**
     * Add header rule
     * @description Add a response header rule to the service with the provided ID.
     */
    post: operations['add-headers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/headers/{headerId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The id of the header */
        headerId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete header rule
     * @description Delete a particular response header rule for a particular service.
     */
    delete: operations['delete-header'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/routes': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List redirect/rewrite rules
     * @description List a particular service's redirect/rewrite rules that match the provided filters. If no filters are provided, all rules for the service are returned.
     */
    get: operations['list-routes'];
    /**
     * Update redirect/rewrite rules
     * @description Replace all redirect/rewrite rules for a particular service with the provided list.
     *
     *     **This deletes all existing redirect/rewrite rules for the service that aren't included in the request.**
     *
     *     Rule priority is assigned according to list order (the first rule in the list has the highest priority).
     */
    put: operations['put-routes'];
    /**
     * Add redirect/rewrite rules
     * @description Add redirect/rewrite rules to the service with the provided ID.
     */
    post: operations['add-route'];
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update redirect/rewrite rule priority
     * @description Update the priority for a particular redirect/rewrite rule.
     *
     *     To apply redirect/rewrite rules to an incoming request, Render starts from the rule with priority `0` and applies the first encountered rule that matches the request's path (if any).
     *
     *     Render increments the priority of other rules by `1` as necessary to make space for the updated rule.
     */
    patch: operations['patch-route'];
    trace?: never;
  };
  '/services/{serviceId}/routes/{routeId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The id of the route */
        routeId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete redirect/rewrite rule
     * @description Delete a particular redirect/rewrite rule for a particular service.
     */
    delete: operations['delete-route'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/custom-domains': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List custom domains
     * @description List a particular service's custom domains that match the provided filters. If no filters are provided, all custom domains for the service are returned.
     */
    get: operations['list-custom-domains'];
    put?: never;
    /**
     * Add custom domain
     * @description Add a custom domain to the service with the provided ID.
     */
    post: operations['create-custom-domain'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/custom-domains/{customDomainIdOrName}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID or name of the custom domain */
        customDomainIdOrName: components['parameters']['customDomainIdOrNameParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve custom domain
     * @description Retrieve a particular custom domain for a particular service.
     */
    get: operations['retrieve-custom-domain'];
    put?: never;
    post?: never;
    /**
     * Delete custom domain
     * @description Delete a custom domain for a service given the service id and custom domain id or name.
     */
    delete: operations['delete-custom-domain'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/custom-domains/{customDomainIdOrName}/verify': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID or name of the custom domain */
        customDomainIdOrName: components['parameters']['customDomainIdOrNameParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify DNS configuration
     * @description Verify the DNS configuration for a custom domain.
     */
    post: operations['refresh-custom-domain'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/suspend': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Suspend service
     * @description Suspend the service with the provided ID.
     */
    post: operations['suspend-service'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/resume': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resume service
     * @description Resume the service with the provided ID (if it's currently suspended).
     */
    post: operations['resume-service'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/restart': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restart service
     * @description Restart the service with the provided ID.
     *
     *     Not supported for cron jobs.
     */
    post: operations['restart-service'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/scale': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Scale instance count
     * @description [Scale](https://render.com/docs/scaling#manual-scaling) the service with the provided ID to a fixed number of instances.
     *
     *     Render ignores this value as long as autoscaling is enabled for the service.
     */
    post: operations['scale-service'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/autoscaling': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    /**
     * Update autoscaling config
     * @description Update the [autoscaling](https://render.com/docs/scaling#autoscaling) config for the service with the provided ID.
     */
    put: operations['autoscale-service'];
    post?: never;
    /**
     * Delete autoscaling config
     * @description Delete the autoscaling config for a service given the service id.
     */
    delete: operations['delete-autoscaling-config'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/preview': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create service preview (image-backed)
     * @description Create a preview instance for an image-backed service. The preview uses the settings of the base service (referenced by `serviceId`), except settings overridden via provided parameters.
     *
     *     View all active previews from your service's Previews tab in the Render Dashboard.
     *
     *     Note that you can't create previews for Git-backed services using the Render API.
     */
    post: operations['preview-service'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/jobs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List jobs
     * @description List jobs for the provided service that match the provided filters. If no filters are provided, all jobs for the service are returned.
     */
    get: operations['list-job'];
    put?: never;
    /**
     * Create job
     * @description Create a one-off job using the provided service. For details, see [One-Off Jobs](https://render.com/docs/one-off-jobs).
     */
    post: operations['post-job'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/jobs/{jobId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the job */
        jobId: components['parameters']['jobId'];
      };
      cookie?: never;
    };
    /**
     * Retrieve job
     * @description Retrieve the details of a particular one-off job for a particular service.
     */
    get: operations['retrieve-job'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/jobs/{jobId}/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the job */
        jobId: components['parameters']['jobId'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel running job
     * @description Cancel a particular one-off job for a particular service.
     */
    post: operations['cancel-job'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/services/{serviceId}/instances': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    /**
     * List instances
     * @description List instances for the provided service.
     */
    get: operations['list-instances'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cron-jobs/{cronJobId}/runs': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the cron job */
        cronJobId: components['parameters']['cronJobIdParam'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger cron job run
     * @description Trigger a run for a cron job and cancel any active runs.
     */
    post: operations['run-cron-job'];
    /**
     * Cancel running cron job
     * @description Cancel a currently running cron job.
     */
    delete: operations['cancel-cron-job-run'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/events/{eventId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the event */
        eventId: components['schemas']['eventId'];
      };
      cookie?: never;
    };
    /**
     * Retrieve event
     * @description Retrieve the details of a particular event
     */
    get: operations['retrieve-event'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List logs
     * @description List logs matching the provided filters. Logs are paginated by start and end timestamps.
     *     There are more logs to fetch if `hasMore` is true in the response. Provide the `nextStartTime`
     *     and `nextEndTime` timestamps as the `startTime` and `endTime` query parameters to fetch the next page of logs.
     *
     *     You can query for logs across multiple resources, but all resources must be in the same region and belong to the same owner.
     */
    get: operations['list-logs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs/subscribe': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Subscribe to new logs
     * @description Open a websocket connection to subscribe to logs matching the provided filters. Logs are streamed in real-time as they are generated.
     *
     *     You can query for logs across multiple resources, but all resources must be in the same region and belong to the same owner.
     */
    get: operations['subscribe-logs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs/values': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List log label values
     * @description List all values for a given log label in the logs matching the provided filters.
     */
    get: operations['list-logs-values'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs/streams/owner/{ownerId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve log stream
     * @description Returns log stream information for the specified workspace.
     */
    get: operations['get-owner-log-stream'];
    /**
     * Update log stream
     * @description Updates log stream information for the specified workspace. All logs for resources owned by this workspace will be sent to this log stream unless overridden by individual resources.
     */
    put: operations['update-owner-log-stream'];
    post?: never;
    /**
     * Delete log stream
     * @description Removes the log stream for the specified workspace.
     */
    delete: operations['delete-owner-log-stream'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs/streams/resource': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List log stream overrides
     * @description Lists log stream overrides for the provided workspace that match the provided filters. These overrides take precedence over the workspace's default log stream.
     */
    get: operations['list-resource-log-streams'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logs/streams/resource/{resourceId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve log stream override
     * @description Returns log stream override information for the specified resource. A log stream override takes precedence over a workspace's default log stream.
     */
    get: operations['get-resource-log-stream'];
    /**
     * Update log stream override
     * @description Updates log stream override information for the specified resource. A log stream override takes precedence over a workspace's default log stream.
     */
    put: operations['update-resource-log-stream'];
    post?: never;
    /**
     * Delete log stream override
     * @description Removes the log stream override for the specified resource. After deletion, the resource will use the workspace's default log stream setting.
     */
    delete: operations['delete-resource-log-stream'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics-stream/{ownerId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return metrics stream information for */
        ownerId: string;
      };
      cookie?: never;
    };
    /**
     * Retrieve metrics stream
     * @description Returns metrics stream information for the specified workspace.
     */
    get: operations['getOwnerMetricsStream'];
    /**
     * Create or update metrics stream
     * @description Creates or updates the metrics stream for the specified workspace.
     */
    put: operations['upsertOwnerMetricsStream'];
    post?: never;
    /**
     * Delete metrics stream
     * @description Deletes the metrics stream for the specified workspace.
     */
    delete: operations['deleteOwnerMetricsStream'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/cpu': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
        /** @description The aggregation method to apply to multiple time series */
        aggregationMethod?: components['parameters']['applicationMetricAggregationMethod'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get CPU usage
     * @description Get CPU usage for one or more resources.
     */
    get: operations['get-cpu'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/cpu-limit': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get CPU limit
     * @description Get the CPU limit for one or more resources.
     */
    get: operations['get-cpu-limit'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/cpu-target': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get CPU target
     * @description Get CPU target for one or more resources.
     */
    get: operations['get-cpu-target'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/memory': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get memory usage
     * @description Get memory usage for one or more resources.
     */
    get: operations['get-memory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/memory-limit': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get memory limit
     * @description Get the memory limit for one or more resources.
     */
    get: operations['get-memory-limit'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/memory-target': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get memory target
     * @description Get memory target for one or more resources.
     */
    get: operations['get-memory-target'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/http-requests': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
        path?: components['parameters']['pathQueryParam'];
        /** @description The field to aggregate by */
        aggregateBy?: components['parameters']['httpAggregateBy'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get HTTP request count
     * @description Get the HTTP request count for one or more resources.
     */
    get: operations['get-http-requests'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/http-latency': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
        path?: components['parameters']['pathQueryParam'];
        /** @description The quantile of latencies to fetch. When multiple quantile query params are provided, they are ORed together */
        quantile?: components['parameters']['quantile'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get HTTP latency
     * @description Get HTTP latency metrics for one or more resources.
     */
    get: operations['get-http-latency'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/bandwidth': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get bandwidth usage
     * @description Get bandwidth usage for one or more resources.
     */
    get: operations['get-bandwidth'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/bandwidth-sources': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get bandwidth usage breakdown by traffic source
     * @description Get bandwidth usage for one or more resources broken down by traffic source (HTTP, WebSocket, NAT, PrivateLink).
     *
     *     Returns hourly data points with traffic source breakdown. Traffic source data is available from March 9, 2025 onwards.
     *     Queries for earlier dates will return a 400 Bad Request error.
     */
    get: operations['get-bandwidth-sources'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/disk-usage': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get disk usage
     * @description Get persistent disk usage for one or more resources.
     */
    get: operations['get-disk-usage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/disk-capacity': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get disk capacity
     * @description Get persistent disk capacity for one or more resources.
     */
    get: operations['get-disk-capacity'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/instance-count': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get instance count
     * @description Get the instance count for one or more resources.
     */
    get: operations['get-instance-count'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/active-connections': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources Postgres ids or Redis ids */
        resource?: components['parameters']['datastoreResourceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get active connection count
     * @description Get the number of active connections for one or more Postgres databases or Redis instances.
     */
    get: operations['get-active-connections'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/replication-lag': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Postgres ID to query. When multiple resource query params are provided, they are ORed together */
        resource?: components['parameters']['postgresResourceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get replica lag
     * @description Get seconds of replica lag of a Postgres replica.
     */
    get: operations['get-replication-lag'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/filters/application': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List queryable instance values
     * @description List instance values to filter by for one or more resources.
     */
    get: operations['list-application-filter-values'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/filters/http': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The status codes of HTTP requests to filter to. When multiple status code query params are provided, they are ORed together */
        statusCode?: components['parameters']['httpStatusCode'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List queryable status codes and host values
     * @description List status codes and host values to filter by for one or more resources.
     */
    get: operations['list-http-filter-values'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/filters/path': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The status codes of HTTP requests to filter to. When multiple status code query params are provided, they are ORed together */
        statusCode?: components['parameters']['httpStatusCode'];
        /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
        path?: components['parameters']['pathQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List queryable paths
     * @description The path suggestions are based on the most recent 5000 log lines as filtered by the provided filters
     */
    get: operations['list-path-filter-values'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/key-value': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Key Value instances
     * @description List Key Value instances matching the provided filters. If no filters are provided, all Key Value instances are returned.
     */
    get: operations['list-key-value'];
    put?: never;
    /**
     * Create Key Value instance
     * @description Create a new Key Value instance.
     */
    post: operations['create-key-value'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/key-value/{keyValueId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Key Value instance
     * @description Retrieve a Key Value instance by ID.
     */
    get: operations['retrieve-key-value'];
    put?: never;
    post?: never;
    /**
     * Delete Key Value instance
     * @description Delete a Key Value instance by ID.
     */
    delete: operations['delete-key-value'];
    options?: never;
    head?: never;
    /**
     * Update Key Value instance
     * @description Update a Key Value instance by ID.
     */
    patch: operations['update-key-value'];
    trace?: never;
  };
  '/key-value/{keyValueId}/connection-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Key Value connection info
     * @description Retrieve connection info for a Key Value instance by ID. Connection info includes sensitive information.
     */
    get: operations['retrieve-key-value-connection-info'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/redis': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Redis instances
     * @deprecated
     * @description List Redis instances matching the provided filters. If no filters are provided, all Redis instances are returned.
     *     This API is deprecated in favor of the Key Value API.
     */
    get: operations['list-redis'];
    put?: never;
    /**
     * Create Redis instance
     * @deprecated
     * @description Create a new Redis instance. This API is deprecated in favor of the Key Value API.
     */
    post: operations['create-redis'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/redis/{redisId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Redis instance
     * @deprecated
     * @description Retrieve a Redis instance by ID. This API is deprecated in favor of the Key Value API.
     */
    get: operations['retrieve-redis'];
    put?: never;
    post?: never;
    /**
     * Delete Redis instance
     * @deprecated
     * @description Delete a Redis instance by ID. This API is deprecated in favor of the Key Value API.
     */
    delete: operations['delete-redis'];
    options?: never;
    head?: never;
    /**
     * Update Redis instance
     * @deprecated
     * @description Update a Redis instance by ID. This API is deprecated in favor of the Key Value API.
     */
    patch: operations['update-redis'];
    trace?: never;
  };
  '/redis/{redisId}/connection-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Redis connection info
     * @deprecated
     * @description Retrieve connection info for a Redis instance by ID. Connection info includes sensitive information.
     *     This API is deprecated in favor of the Key Value API.
     */
    get: operations['retrieve-redis-connection-info'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Postgres instances
     * @description List Postgres instances matching the provided filters. If no filters are provided, all Postgres instances are returned.
     */
    get: operations['list-postgres'];
    put?: never;
    /**
     * Create Postgres instance
     * @description Create a new Postgres instance.
     */
    post: operations['create-postgres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Postgres instance
     * @description Retrieve a Postgres instance by ID.
     */
    get: operations['retrieve-postgres'];
    put?: never;
    post?: never;
    /**
     * Delete Postgres instance
     * @description Delete a Postgres instance by ID. This operation is irreversible, and
     *     all data will be lost.
     */
    delete: operations['delete-postgres'];
    options?: never;
    head?: never;
    /**
     * Update Postgres instance
     * @description Update a Postgres instance by ID.
     */
    patch: operations['update-postgres'];
    trace?: never;
  };
  '/postgres/{postgresId}/connection-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Postgres connection info
     * @description Retrieve connection info for a Postgres instance by ID. Connection info includes sensitive information.
     */
    get: operations['retrieve-postgres-connection-info'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}/recovery': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve point-in-time recovery status
     * @description Retrieve information on the availability of Postgres point-in-time recovery for a Postgres instance by ID.
     */
    get: operations['retrieve-postgres-recovery-info'];
    put?: never;
    /**
     * Trigger point-in-time recovery
     * @description Trigger [point-in-time recovery](https://render.com/docs/postgresql-backups) on the Postgres instance with the provided ID.
     */
    post: operations['recover-postgres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}/suspend': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Suspend Postgres instance
     * @description Suspend a Postgres instance by ID.
     */
    post: operations['suspend-postgres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}/resume': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resume Postgres instance
     * @description Resume a Postgres instance by ID.
     */
    post: operations['resume-postgres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}/restart': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restart Postgres instance
     * @description Restart a Postgres instance by ID.
     */
    post: operations['restart-postgres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}/failover': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Failover Postgres instance
     * @description Failover a [highly available Postgres](https://render.com/docs/postgresql-high-availability) instance.
     */
    post: operations['failover-postgres'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/postgres/{postgresId}/export': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    /**
     * List Postgres exports
     * @description List [exports](https://render.com/docs/postgresql-backups#logical-backups) for a Postgres instance by ID. Returns a URL to download the export.
     */
    get: operations['list-postgres-export'];
    put?: never;
    /**
     * Create Postgres export
     * @description Create an [export](https://render.com/docs/postgresql-backups#logical-backups) of a Postgres instance by ID.
     */
    post: operations['create-postgres-export'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List projects
     * @description List projects matching the provided filters. If no filters are provided, all projects are returned.
     */
    get: operations['list-projects'];
    put?: never;
    /**
     * Create project
     * @description Create a new project.
     */
    post: operations['create-project'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{projectId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Project
     * @description Retrieve the project with the provided ID.
     */
    get: operations['retrieve-project'];
    put?: never;
    post?: never;
    /**
     * Delete project
     * @description Delete the project with the provided ID, along with all environments and services in that project.
     *
     *     **This operation is irreversible.** All services and other resources belonging to the project will be deleted.
     */
    delete: operations['delete-project'];
    options?: never;
    head?: never;
    /**
     * Update project
     * @description Update the details of a project.
     *
     *     To update the details of a particular _environment_ in the project, instead use the [Update environment](https://api-docs.render.com/reference/update-environment) endpoint.
     */
    patch: operations['update-project'];
    trace?: never;
  };
  '/environments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List environments
     * @description List a particular project's environments matching the provided filters. If no filters are provided, all environments are returned.
     */
    get: operations['list-environments'];
    put?: never;
    /**
     * Create environment
     * @description Create a new environment belonging to the project with the provided ID.
     */
    post: operations['create-environment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/environments/{environmentId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve environment
     * @description Retrieve the environment with the provided ID.
     */
    get: operations['retrieve-environment'];
    put?: never;
    post?: never;
    /**
     * Delete environment
     * @description Delete the environment with the provided ID, along with all resources that belong to it.
     *
     *     **This operation is irreversible.** All services and other resources belonging to the environment will be deleted.
     */
    delete: operations['delete-environment'];
    options?: never;
    head?: never;
    /**
     * Update environment
     * @description Update the details of the environment with the provided ID.
     */
    patch: operations['update-environment'];
    trace?: never;
  };
  '/environments/{environmentId}/resources': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add resources to environment
     * @description Add resources to the environment with the provided ID.
     */
    post: operations['add-resources-to-environment'];
    /**
     * Remove resources from environment
     * @description Remove resources from the environment with the provided ID.
     */
    delete: operations['remove-resources-from-environment'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/env-groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List environment groups
     * @description List environment groups matching the provided filters. If no filters are provided, all environment groups are returned.
     */
    get: operations['list-env-groups'];
    put?: never;
    /**
     * Create environment group
     * @description Create a new environment group.
     */
    post: operations['create-env-group'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/env-groups/{envGroupId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve environment group
     * @description Retrieve an environment group by ID.
     */
    get: operations['retrieve-env-group'];
    put?: never;
    post?: never;
    /**
     * Delete environment group
     * @description Delete the environment group with the provided ID, including all environment variables and secret files it contains.
     */
    delete: operations['delete-env-group'];
    options?: never;
    head?: never;
    /**
     * Update environment group
     * @description Update the attributes of an environment group.
     */
    patch: operations['update-env-group'];
    trace?: never;
  };
  '/env-groups/{envGroupId}/services/{serviceId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Link service
     * @description Link a particular service to a particular environment group.
     *
     *     The linked service will have access to the environment variables and secret files in the group.
     */
    post: operations['link-service-to-env-group'];
    /**
     * Unlink service
     * @description Unlink a particular service from a particular environment group.
     *
     *     The service will lose access to the environment variables and secret files in the group.
     */
    delete: operations['unlink-service-from-env-group'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/env-groups/{envGroupId}/env-vars/{envVarKey}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve environment variable
     * @description Retrieve a particular environment variable in a particular environment group.
     */
    get: operations['retrieve-env-group-env-var'];
    /**
     * Add or update environment variable
     * @description Add or update a particular environment variable in a particular environment group.
     */
    put: operations['update-env-group-env-var'];
    post?: never;
    /**
     * Remove environment variable
     * @description Remove a particular environment variable from a particular environment group.
     */
    delete: operations['delete-env-group-env-var'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/env-groups/{envGroupId}/secret-files/{secretFileName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve secret file
     * @description Retrieve a particular secret file in a particular environment group.
     */
    get: operations['retrieve-env-group-secret-file'];
    /**
     * Add or update secret file
     * @description Add or update a particular secret file in an particular environment group.
     */
    put: operations['update-env-group-secret-file'];
    post?: never;
    /**
     * Remove secret file
     * @description Remove a particular secret file from a particular environment group.
     */
    delete: operations['delete-env-group-secret-file'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/maintenance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List maintenance runs
     * @description List scheduled and/or recent maintenance runs for specified resources.
     */
    get: operations['list-maintenance'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/maintenance/{maintenanceRunParam}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve maintenance run
     * @description Retrieve the maintenance run with the provided ID.
     */
    get: operations['retrieve-maintenance'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update maintenance run
     * @description Update the maintenance run with the provided ID.
     *
     *     Updates from this endpoint are asynchronous. To check your update's status, use the [Retrieve maintenance run](https://api-docs.render.com/reference/retrieve-maintenance) endpoint.
     */
    patch: operations['update-maintenance'];
    trace?: never;
  };
  '/maintenance/{maintenanceRunParam}/trigger': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger maintenance run
     * @description Trigger the scheduled maintenance run with the provided ID.
     *
     *     Triggering maintenance is asynchronous. To check whether maintenance has started, use the [Retrieve maintenance run](https://api-docs.render.com/reference/retrieve-maintenance) endpoint.
     *
     *     As maintenance progresses, the run's `state` will change from `scheduled` to other values, such as `in_progress` and `succeeded`.
     */
    post: operations['trigger-maintenance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/webhooks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List webhooks
     * @description List webhooks
     */
    get: operations['list-webhooks'];
    put?: never;
    /**
     * Create a webhook
     * @description Create a new webhook.
     */
    post: operations['create-webhook'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/webhooks/{webhookId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the webhook */
        webhookId: components['parameters']['webhookIdParam'];
      };
      cookie?: never;
    };
    /**
     * Retrieve a webhook
     * @description Retrieve the webhook with the provided ID
     */
    get: operations['retrieve-webhook'];
    put?: never;
    post?: never;
    /**
     * Delete a webhook
     * @description Delete the webhook with the provided ID.
     */
    delete: operations['delete-webhook'];
    options?: never;
    head?: never;
    /**
     * Update a webhook
     * @description Update the webhook with the provided ID.
     */
    patch: operations['update-webhook'];
    trace?: never;
  };
  '/webhooks/{webhookId}/events': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the webhook */
        webhookId: components['parameters']['webhookIdParam'];
      };
      cookie?: never;
    };
    /**
     * List webhook events
     * @description Retrieve a list of events that have been sent to this webhook, with optional filtering by timestamp.
     */
    get: operations['list-webhook-events'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all workflows
     * @description Retrieves a paginated list of all workflows, optionally filtered by name, owner, workflow ID, or environment ID.
     */
    get: operations['listWorkflows'];
    put?: never;
    /**
     * Create a workflow
     * @description Creates a new workflow with the specified configuration.
     */
    post: operations['createWorkflow'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/workflows/{workflowId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workflow */
        workflowId: components['parameters']['WorkflowIDParam'];
      };
      cookie?: never;
    };
    /**
     * Get a workflow
     * @description Retrieves detailed information about a specific workflow by its ID.
     */
    get: operations['getWorkflow'];
    put?: never;
    post?: never;
    /**
     * Delete a workflow
     * @description Deletes the specified workflow permanently.
     */
    delete: operations['deleteWorkflow'];
    options?: never;
    head?: never;
    /**
     * Update a workflow
     * @description Updates an existing workflow with the provided modifications.
     */
    patch: operations['updateWorkflow'];
    trace?: never;
  };
  '/workflowversions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List workflow versions
     * @description Retrieves a paginated list of workflow versions, optionally filtered by owner, workflow ID, or version ID.
     */
    get: operations['listWorkflowVersions'];
    put?: never;
    /**
     * Deploy a workflow version
     * @description Creates and deploys a new version of a workflow.
     */
    post: operations['createWorkflowVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/workflowversions/{workflowVersionId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workflow version */
        workflowVersionId: components['parameters']['WorkflowVersionIDParam'];
      };
      cookie?: never;
    };
    /**
     * Get a workflow version
     * @description Retrieves detailed information about a specific workflow version by its ID.
     */
    get: operations['getWorkflowVersion'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/tasks': {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /**
         * @description An array of either task identifiers which can be either a task ID or a workflow slug with task name and optional version. If a version is not provided, the latest version of the task will be used.
         * @example [
         *       "tsk-1234",
         *       "my-workflow-slug/my-task",
         *       "my-workflow-slug/my-task:SHA123"
         *     ]
         */
        taskId?: components['parameters']['TaskIdFilterParam'];
        /** @description An array of workflow version IDs */
        workflowVersionId?: components['parameters']['WorkflowVersionIDFilterParam'];
        /** @description An array of workflow IDs */
        workflowId?: components['parameters']['WorkflowIDFilterParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List tasks
     * @description Retrieves a paginated list of tasks, optionally filtered by owner, task ID, workflow version ID, or workflow ID.
     */
    get: operations['listTasks'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/tasks/{taskId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the task */
        taskId: components['parameters']['TaskIDParam'];
      };
      cookie?: never;
    };
    /**
     * Get a task
     * @description Retrieves detailed information about a specific task by its ID.
     */
    get: operations['getTask'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/task-runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List task runs
     * @description Retrieves a paginated list of task runs, optionally filtered by task ID, root task run ID, owner, workflow version ID, or workflow ID.
     */
    get: operations['listTaskRuns'];
    put?: never;
    /**
     * Run a task
     * @description Creates and initiates a new task run with the specified parameters.
     */
    post: operations['createTask'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/task-runs/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream realtime events (SSE)
     * @description Establishes a unidirectional event stream. The server sends events as lines
     *     formatted per the SSE spec. Clients SHOULD set `Accept: text/event-stream`
     *     and keep the connection open.
     */
    get: operations['streamTaskRunsEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/task-runs/{taskRunId}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the task run */
        taskRunId: components['parameters']['TaskRunIDParam'];
      };
      cookie?: never;
    };
    /**
     * Get a task run
     * @description Retrieves detailed information about a specific task run by its ID.
     */
    get: operations['getTaskRun'];
    put?: never;
    post?: never;
    /**
     * Cancel a task run
     * @description Cancels a running task and removes it from the execution queue.
     */
    delete: operations['cancelTaskRun'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    cursor: string;
    auditLogWithCursor: {
      cursor: components['schemas']['cursor'];
      auditLog: components['schemas']['auditLog'];
    };
    auditLog: {
      /**
       * @description Unique identifier for the audit log entry
       * @example aud-123456789
       */
      id: string;
      /**
       * Format: date-time
       * @description When the event occurred (ISO 8601 format)
       * @example 2023-10-01T12:00:00Z
       */
      timestamp: string;
      /**
       * @description The type of event that occurred
       * @example CreateServerEvent
       * @enum {string}
       */
      event:
        | 'AcceptOrgInviteEvent'
        | 'AcceptTeamInviteEvent'
        | 'AddOrgMemberEvent'
        | 'ApplyBlueprintEvent'
        | 'ChangeEnvironmentProtectionEvent'
        | 'ChangeOrg2FAEnforcementEvent'
        | 'ChangeOrgAllowedLoginMethodsEvent'
        | 'ChangeOrgRoleEvent'
        | 'ChangeTeam2FAEnforcementEvent'
        | 'ChangeTeamAllowedLoginMethodsEvent'
        | 'ChangeTeamMemberRoleEvent'
        | 'ChangeWorkspaceDeployHandlingEvent'
        | 'ChangeWorkspacePrivacyEvent'
        | 'CreateCronJobEvent'
        | 'CreateEnvVarsEvent'
        | 'CreateEnvironmentEvent'
        | 'CreateOrgDomainEvent'
        | 'CreateOtelIntegrationEvent'
        | 'CreatePostgresEvent'
        | 'CreatePrivateLinkEvent'
        | 'CreateProjectEvent'
        | 'CreateRedisEvent'
        | 'CreateSSOConnectionEvent'
        | 'CreateServerDiskEvent'
        | 'CreateServerEvent'
        | 'CreateWebhookEvent'
        | 'CreateWorkspaceEvent'
        | 'DeleteCronJobEvent'
        | 'DeleteEnvGroupEvent'
        | 'DeleteEnvVarsEvent'
        | 'DeleteEnvironmentEvent'
        | 'DeleteOrgDomainEvent'
        | 'DeleteOtelIntegrationEvent'
        | 'DeletePostgresEvent'
        | 'DeletePrivateLinkEvent'
        | 'DeleteProjectEvent'
        | 'DeleteRedisEvent'
        | 'DeleteSSOConnectionEvent'
        | 'DeleteServerDiskEvent'
        | 'DeleteServerEvent'
        | 'DeleteWebhookEvent'
        | 'DeleteWorkspaceEvent'
        | 'DocumentDownloadEvent'
        | 'DownloadDatabaseBackupEvent'
        | 'EnableRedisInternalAuthEvent'
        | 'InviteToOrgEvent'
        | 'InviteToTeamEvent'
        | 'JoinTeamEvent'
        | 'LoginEvent'
        | 'LogoutEvent'
        | 'MaintenanceModeEnabledEvent'
        | 'MaintenanceModeURIUpdatedEvent'
        | 'MoveEnvironmentResourceEvent'
        | 'ProvisionOrganizationSCIMToken'
        | 'RemoveOrgMemberEvent'
        | 'RemoveUserFromTeamEvent'
        | 'RestoreDiskSnapshotEvent'
        | 'ResumePostgresEvent'
        | 'ResumeServiceEvent'
        | 'RevokeOrganizationSCIMToken'
        | 'SignNDAEvent'
        | 'StartShellEvent'
        | 'SuspendPostgresEvent'
        | 'SuspendServiceEvent'
        | 'UpdateEnvVarsEvent'
        | 'UpdateIPAllowListEvent'
        | 'UpdateOtelIntegrationEvent'
        | 'UpdateSSOConnectionEvent'
        | 'UpdateServiceNameEvent'
        | 'UpdateWebhookEvent'
        | 'VerifyOrgDomainEvent'
        | 'ViewConnectionInfoEvent'
        | 'ViewEnvVarValuesEvent';
      /**
       * @description The status of the event
       * @example success
       * @enum {string}
       */
      status: 'success' | 'error';
      actor: components['schemas']['auditLogActor'];
      /**
       * @description Additional context information about the event
       * @example {
       *       "service": "srv-123456789",
       *       "field": "env_vars"
       *     }
       */
      metadata: {
        [key: string]: string;
      };
    };
    auditLogActor: {
      /**
       * @description The type of actor that performed the action
       * @example user
       * @enum {string}
       */
      type: 'user' | 'rest_api' | 'system';
      /**
       * @description Email address of the actor (if applicable)
       * @example user@example.com
       */
      email?: string;
      /**
       * @description Unique identifier of the actor (if applicable)
       * @example usr-123456789
       */
      id?: string;
    };
    service: {
      id: string;
      autoDeploy: components['schemas']['autoDeploy'];
      autoDeployTrigger?: components['schemas']['autoDeployTrigger'];
      branch?: string;
      buildFilter?: components['schemas']['buildFilter'];
      /** Format: date-time */
      createdAt: string;
      /** @description The URL to view the service in the Render Dashboard */
      dashboardUrl: string;
      environmentId?: string;
      imagePath?: string;
      name: string;
      notifyOnFail: components['schemas']['notifySetting'];
      ownerId: string;
      registryCredential?: components['schemas']['registryCredentialSummary'];
      /** @example https://github.com/render-examples/flask-hello-world */
      repo?: string;
      rootDir: string;
      slug: string;
      /** @enum {string} */
      suspended: 'suspended' | 'not_suspended';
      suspenders: components['schemas']['suspenderType'][];
      type: components['schemas']['serviceType'];
      /** Format: date-time */
      updatedAt: string;
      serviceDetails:
        | components['schemas']['staticSiteDetails']
        | components['schemas']['webServiceDetails']
        | components['schemas']['privateServiceDetails']
        | components['schemas']['backgroundWorkerDetails']
        | components['schemas']['cronJobDetails'];
    };
    deployList: components['schemas']['deployWithCursor'][];
    workflowVersionWithCursor: {
      workflowVersion: components['schemas']['WorkflowVersion'];
      cursor: components['schemas']['cursor'];
    };
    workflowWithCursor: {
      workflow: components['schemas']['Workflow'];
      cursor: components['schemas']['cursor'];
    };
    taskWithCursor: {
      task: components['schemas']['Task'];
      cursor: components['schemas']['cursor'];
    };
    deployWithCursor: {
      deploy?: components['schemas']['deploy'];
      cursor?: components['schemas']['cursor'];
    };
    serviceAndDeploy: {
      service?: components['schemas']['service'];
      deployId?: string;
    };
    /**
     * @default yes
     * @enum {string}
     */
    autoDeploy: 'yes' | 'no';
    /**
     * @description Controls autodeploy behavior. commit deploys when a commit is pushed to a branch. checksPass waits for the branch to be green.
     * @enum {string}
     */
    autoDeployTrigger: 'commit' | 'off' | 'checksPass';
    buildFilter: {
      paths: string[];
      ignoredPaths: string[];
    };
    registryCredentialSummary: {
      id: string;
      name: string;
    };
    /**
     * @description The registry to use this credential with
     * @enum {string}
     */
    registryCredentialRegistry: 'GITHUB' | 'GITLAB' | 'DOCKER' | 'GOOGLE_ARTIFACT' | 'AWS_ECR';
    registryCredential: {
      /** @description Unique identifier for this credential */
      id: string;
      /** @description Descriptive name for this credential */
      name: string;
      registry: components['schemas']['registryCredentialRegistry'];
      /** @description The username associated with the credential */
      username: string;
      /**
       * Format: date-time
       * @description Last updated time for the credential
       */
      updatedAt: string;
    };
    image: {
      /** @description The ID of the owner for this image. This should match the owner of the service as well as the owner of any specified registry credential. */
      ownerId: string;
      /** @description Optional reference to the registry credential passed to the image repository to retrieve this image. */
      registryCredentialId?: string;
      /** @description Path to the image used for this server (e.g docker.io/library/nginx:latest). */
      imagePath: string;
    };
    dockerDetails: {
      dockerCommand: string;
      dockerContext: string;
      dockerfilePath: string;
      preDeployCommand?: string;
      registryCredential?: components['schemas']['registryCredential'];
    };
    nativeEnvironmentDetails: {
      buildCommand: string;
      startCommand: string;
      preDeployCommand?: string;
    };
    staticSiteDetails: {
      buildCommand: string;
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      parentServer?: components['schemas']['resource'];
      publishPath: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      url: string;
      buildPlan: components['schemas']['buildPlan'];
      renderSubdomainPolicy?: components['schemas']['renderSubdomainPolicy'];
    };
    maintenanceMode: {
      enabled: boolean;
      /** @description The page to be served when [maintenance mode](https://render.com/docs/maintenance-mode) is enabled. When empty, the default maintenance mode page is served. */
      uri: string;
    };
    /**
     * @description The maximum amount of time (in seconds) that Render waits for your application process to exit gracefully after sending it a SIGTERM signal.
     * @default 30
     */
    maxShutdownDelaySeconds: number;
    webServiceDetails: {
      autoscaling?: components['schemas']['autoscalingConfig'];
      cache?: components['schemas']['cache'];
      disk?: components['schemas']['disk'];
      env: components['schemas']['serviceEnv'];
      envSpecificDetails: components['schemas']['envSpecificDetails'];
      healthCheckPath: string;
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      maintenanceMode?: components['schemas']['maintenanceMode'];
      /** @description For a *manually* scaled service, this is the number of instances the service is scaled to. DOES NOT indicate the number of running instances for an *autoscaled* service. */
      numInstances: number;
      openPorts: components['schemas']['serverPort'][];
      parentServer?: components['schemas']['resource'];
      plan: components['schemas']['plan'];
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      region: components['schemas']['region'];
      runtime: components['schemas']['serviceRuntime'];
      sshAddress?: components['schemas']['sshAddress'];
      url: string;
      buildPlan: components['schemas']['buildPlan'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
      renderSubdomainPolicy?: components['schemas']['renderSubdomainPolicy'];
    };
    envSpecificDetails:
      | components['schemas']['dockerDetails']
      | components['schemas']['nativeEnvironmentDetails'];
    envSpecificDetailsPATCH:
      | components['schemas']['dockerDetailsPATCH']
      | components['schemas']['nativeEnvironmentDetailsPATCH'];
    envSpecificDetailsPOST:
      | components['schemas']['dockerDetailsPOST']
      | components['schemas']['nativeEnvironmentDetailsPOST'];
    resource: {
      id: string;
      name: string;
    };
    privateServiceDetails: {
      autoscaling?: components['schemas']['autoscalingConfig'];
      disk?: components['schemas']['disk'];
      env: components['schemas']['serviceEnv'];
      envSpecificDetails: components['schemas']['envSpecificDetails'];
      /** @description For a *manually* scaled service, this is the number of instances the service is scaled to. DOES NOT indicate the number of running instances for an *autoscaled* service. */
      numInstances: number;
      openPorts: components['schemas']['serverPort'][];
      parentServer?: components['schemas']['resource'];
      plan: components['schemas']['plan'];
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      region: components['schemas']['region'];
      runtime: components['schemas']['serviceRuntime'];
      sshAddress?: components['schemas']['sshAddress'];
      url: string;
      buildPlan: components['schemas']['buildPlan'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
    };
    serviceDisk: {
      name: string;
      mountPath: string;
      /** @description Defaults to 1 */
      sizeGB?: number;
    };
    cache: {
      profile: string;
    };
    diskWithCursor: {
      disk: components['schemas']['diskDetails'];
      cursor: components['schemas']['cursor'];
    };
    /** @description When a service with a disk is scaled, the instanceId is used to identify the instance that the disk is attached to. Each instance's disks get their own snapshots, and can be restored separately. */
    instanceId: string;
    diskSnapshot: {
      /** Format: date-time */
      createdAt?: string;
      snapshotKey?: string;
      instanceId?: components['schemas']['instanceId'];
    };
    snapshotRestorePOST: {
      snapshotKey: string;
      instanceId?: components['schemas']['instanceId'];
    };
    backgroundWorkerDetails: {
      autoscaling?: components['schemas']['autoscalingConfig'];
      disk?: components['schemas']['disk'];
      env: components['schemas']['serviceEnv'];
      envSpecificDetails: components['schemas']['envSpecificDetails'];
      /** @description For a *manually* scaled service, this is the number of instances the service is scaled to. DOES NOT indicate the number of running instances for an *autoscaled* service. */
      numInstances: number;
      parentServer?: components['schemas']['resource'];
      plan: components['schemas']['plan'];
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      region: components['schemas']['region'];
      runtime: components['schemas']['serviceRuntime'];
      sshAddress?: components['schemas']['sshAddress'];
      buildPlan: components['schemas']['buildPlan'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
    };
    cronJobDetails: {
      env: components['schemas']['serviceEnv'];
      envSpecificDetails: components['schemas']['envSpecificDetails'];
      /** Format: date-time */
      lastSuccessfulRunAt?: string;
      plan: components['schemas']['plan'];
      region: components['schemas']['region'];
      runtime: components['schemas']['serviceRuntime'];
      schedule: string;
      buildPlan: components['schemas']['buildPlan'];
    };
    serviceList: components['schemas']['serviceWithCursor'][];
    serviceWithCursor: {
      service: components['schemas']['service'];
      cursor: components['schemas']['cursor'];
    };
    servicePOST: {
      type: components['schemas']['serviceType'];
      name: string;
      ownerId: string;
      /**
       * @description Do not include the branch in the repo string. You can instead supply a 'branch' parameter.
       * @example https://github.com/render-examples/flask-hello-world
       */
      repo?: string;
      autoDeploy?: components['schemas']['autoDeploy'];
      autoDeployTrigger?: components['schemas']['autoDeployTrigger'];
      /** @description If left empty, this will fall back to the default branch of the repository */
      branch?: string;
      image?: components['schemas']['image'];
      buildFilter?: components['schemas']['buildFilter'];
      rootDir?: string;
      envVars?: components['schemas']['envVarInputArray'];
      secretFiles?: components['schemas']['secretFileInput'][];
      /** @description The ID of the environment the service is associated with */
      environmentId?: string;
      serviceDetails?:
        | components['schemas']['staticSiteDetailsPOST']
        | components['schemas']['webServiceDetailsPOST']
        | components['schemas']['privateServiceDetailsPOST']
        | components['schemas']['backgroundWorkerDetailsPOST']
        | components['schemas']['cronJobDetailsPOST'];
    };
    dockerDetailsPOST: {
      dockerCommand?: string;
      dockerContext?: string;
      /** @description Defaults to "./Dockerfile" */
      dockerfilePath?: string;
      registryCredentialId?: string;
    };
    /** @description Fields for native environment (runtime) services */
    nativeEnvironmentDetailsPOST: {
      buildCommand: string;
      startCommand: string;
    };
    staticSiteDetailsPOST: {
      buildCommand?: string;
      headers?: components['schemas']['headerInput'][];
      /** @description Defaults to "public" */
      publishPath?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      routes?: components['schemas']['routePost'][];
      renderSubdomainPolicy?: components['schemas']['renderSubdomainPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    webServiceDetailsPOST: {
      autoscaling?: components['schemas']['autoscalingConfig'];
      disk?: components['schemas']['serviceDisk'];
      env?: components['schemas']['serviceEnv'];
      runtime: components['schemas']['serviceRuntime'];
      envSpecificDetails?: components['schemas']['envSpecificDetailsPOST'];
      healthCheckPath?: string;
      maintenanceMode?: components['schemas']['maintenanceMode'];
      /** @description Defaults to 1 */
      numInstances?: number;
      plan?: components['schemas']['paidPlan'];
      preDeployCommand?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      region?: components['schemas']['region'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
      renderSubdomainPolicy?: components['schemas']['renderSubdomainPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    privateServiceDetailsPOST: {
      autoscaling?: components['schemas']['autoscalingConfig'];
      disk?: components['schemas']['serviceDisk'];
      env?: components['schemas']['serviceEnv'];
      runtime: components['schemas']['serviceRuntime'];
      envSpecificDetails?: components['schemas']['envSpecificDetailsPOST'];
      /**
       * @description Defaults to 1
       * @default 1
       */
      numInstances: number;
      plan?: components['schemas']['paidPlan'];
      preDeployCommand?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      region?: components['schemas']['region'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
    };
    backgroundWorkerDetailsPOST: {
      autoscaling?: components['schemas']['autoscalingConfig'];
      disk?: components['schemas']['serviceDisk'];
      env?: components['schemas']['serviceEnv'];
      runtime: components['schemas']['serviceRuntime'];
      envSpecificDetails?: components['schemas']['envSpecificDetailsPOST'];
      /**
       * @description Defaults to 1
       * @default 1
       */
      numInstances: number;
      plan?: components['schemas']['paidPlan'];
      preDeployCommand?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      region?: components['schemas']['region'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
    };
    cronJobDetailsPOST: {
      env?: components['schemas']['serviceEnv'];
      runtime: components['schemas']['serviceRuntime'];
      envSpecificDetails?: components['schemas']['envSpecificDetails'];
      plan?: components['schemas']['paidPlan'];
      region?: components['schemas']['region'];
      schedule: string;
    };
    servicePATCH: {
      autoDeploy?: components['schemas']['autoDeploy'];
      autoDeployTrigger?: components['schemas']['autoDeployTrigger'];
      repo?: string;
      branch?: string;
      image?: components['schemas']['image'];
      name?: string;
      buildFilter?: components['schemas']['buildFilter'];
      rootDir?: string;
      serviceDetails?:
        | components['schemas']['staticSiteDetailsPATCH']
        | components['schemas']['webServiceDetailsPATCH']
        | components['schemas']['privateServiceDetailsPATCH']
        | components['schemas']['backgroundWorkerDetailsPATCH']
        | components['schemas']['cronJobDetailsPATCH'];
    };
    dockerDetailsPATCH: {
      dockerCommand?: string;
      dockerContext?: string;
      dockerfilePath?: string;
      registryCredentialId?: string;
    };
    nativeEnvironmentDetailsPATCH: {
      buildCommand?: string;
      startCommand?: string;
    };
    staticSiteDetailsPATCH: {
      buildCommand?: string;
      publishPath?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      renderSubdomainPolicy?: components['schemas']['renderSubdomainPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    webServiceDetailsPATCH: {
      envSpecificDetails?: components['schemas']['envSpecificDetailsPATCH'];
      healthCheckPath?: string;
      maintenanceMode?: components['schemas']['maintenanceMode'];
      plan?: components['schemas']['paidPlan'];
      preDeployCommand?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      runtime?: components['schemas']['serviceRuntime'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
      renderSubdomainPolicy?: components['schemas']['renderSubdomainPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      cache?: components['schemas']['cache'];
    };
    privateServiceDetailsPATCH: {
      envSpecificDetails?: components['schemas']['envSpecificDetailsPATCH'];
      plan?: components['schemas']['paidPlan'];
      preDeployCommand?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      runtime?: components['schemas']['serviceRuntime'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
    };
    backgroundWorkerDetailsPATCH: {
      envSpecificDetails?: components['schemas']['envSpecificDetailsPATCH'];
      plan?: components['schemas']['paidPlan'];
      preDeployCommand?: string;
      pullRequestPreviewsEnabled?: components['schemas']['pullRequestPreviewsEnabled'];
      previews?: components['schemas']['previews'];
      runtime?: components['schemas']['serviceRuntime'];
      maxShutdownDelaySeconds?: components['schemas']['maxShutdownDelaySeconds'];
    };
    cronJobDetailsPATCH: {
      envSpecificDetails?: components['schemas']['envSpecificDetailsPATCH'];
      plan?: components['schemas']['paidPlan'];
      schedule?: string;
      runtime?: components['schemas']['serviceRuntime'];
    };
    envVarInputArray: components['schemas']['envVarInput'][];
    envVarInput:
      | components['schemas']['envVarKeyValue']
      | components['schemas']['envVarKeyGenerateValue'];
    envVarKeyValue: {
      key: string;
      value: string;
    };
    envVarValue: {
      value: string;
    };
    envVarKeyGenerateValue: {
      key: string;
      generateValue: boolean;
    };
    envVarGenerateValue: {
      generateValue: boolean;
    };
    addUpdateEnvVarInput:
      | components['schemas']['envVarValue']
      | components['schemas']['envVarGenerateValue'];
    previewInput: {
      /**
       * @description Must be either a full URL or the relative path to an image. If a relative path, Render uses the base service's image URL as its root. For example, if the base service's image URL is `docker.io/library/nginx:latest`, then valid values are: `docker.io/library/nginx:<any tag or SHA>`, `library/nginx:<any tag or SHA>`, or `nginx:<any tag or SHA>`. Note that the path must match (only the tag or SHA can vary).
       * @example docker.io/library/nginx:latest
       */
      imagePath: string;
      /**
       * @description A name for the service preview instance. If not specified, Render generates the name using the base service's name and the specified tag or SHA.
       * @example preview
       */
      name?: string;
      plan?: components['schemas']['plan'];
    };
    /**
     * @description The instance type to use for the preview instance. Note that base services with any paid instance type can't create preview instances with the `free` instance type.
     * @example starter
     * @enum {string}
     */
    plan:
      | 'starter'
      | 'starter_plus'
      | 'standard'
      | 'standard_plus'
      | 'pro'
      | 'pro_plus'
      | 'pro_max'
      | 'pro_ultra'
      | 'free'
      | 'custom';
    header: {
      id: string;
      path: string;
      name: string;
      value: string;
    };
    headerInput: {
      /**
       * @description The request path to add the header to. Wildcards will cause headers to be applied to all matching paths.
       * @example /static/*
       */
      path: string;
      /**
       * @description Header name
       * @example Cache-Control
       */
      name: string;
      /**
       * @description Header value
       * @example public, max-age=604800
       */
      value: string;
    };
    notificationOverrideWithCursor: {
      override: components['schemas']['notificationOverride'];
      cursor: components['schemas']['cursor'];
    };
    owner: {
      id: string;
      name: string;
      email: string;
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      /** @description Whether two-factor authentication is enabled for the owner. Only present if `type` is `user`. */
      twoFactorAuthEnabled?: boolean;
      /** @enum {string} */
      type: 'user' | 'team';
    };
    teamMember: {
      userId: string;
      name: string;
      email: string;
      /** @enum {string} */
      status: 'active' | 'inactive';
      role: string;
      mfaEnabled: boolean;
    };
    teamMembers: components['schemas']['teamMember'][];
    ownerWithCursor: {
      owner?: components['schemas']['owner'];
      cursor?: components['schemas']['cursor'];
    };
    route: {
      id: string;
      type: components['schemas']['routeType'];
      source: string;
      destination: string;
      /** @description Redirect and Rewrite Rules are applied in priority order starting at 0 */
      priority: number;
    };
    headerWithCursor: {
      header: components['schemas']['header'];
      cursor: string;
    };
    routeWithCursor: {
      route: components['schemas']['route'];
      cursor: string;
    };
    routePost: {
      type: components['schemas']['routeType'];
      /** @example /:bar/foo */
      source: string;
      /** @example /foo/:bar */
      destination: string;
      /** @description Redirect and Rewrite Rules are applied in priority order starting at 0. Defaults to last in the priority list. */
      priority?: number;
    };
    routePatch: {
      /** @description Redirect and Rewrite Rules are applied in priority order starting at 0. Moves this route to the specified priority and adjusts other route priorities accordingly. */
      priority: number;
    };
    routePut: {
      type: components['schemas']['routeType'];
      /** @example /:bar/foo */
      source: string;
      /** @example /foo/:bar */
      destination: string;
    };
    /** @enum {string} */
    routeType: 'redirect' | 'rewrite';
    /** @enum {string} */
    serviceType:
      | 'static_site'
      | 'web_service'
      | 'private_service'
      | 'background_worker'
      | 'cron_job';
    /** @enum {string} */
    serviceTypeShort: 'static' | 'web' | 'pserv' | 'worker' | 'cron';
    /**
     * @description Runtime
     * @enum {string}
     */
    serviceRuntime: 'docker' | 'elixir' | 'go' | 'node' | 'python' | 'ruby' | 'rust' | 'image';
    /**
     * @deprecated
     * @description This field has been deprecated, runtime should be used in its place.
     * @enum {string}
     */
    serviceEnv: 'docker' | 'elixir' | 'go' | 'node' | 'python' | 'ruby' | 'rust' | 'image';
    /** @description The SSH address for the service. Only present for services that have SSH enabled. */
    sshAddress: string;
    /**
     * @description Defaults to "oregon"
     * @default oregon
     * @enum {string}
     */
    region: 'frankfurt' | 'oregon' | 'ohio' | 'singapore' | 'virginia';
    /** @enum {string} */
    notifySetting: 'default' | 'notify' | 'ignore';
    /** @enum {string} */
    suspenderType:
      | 'admin'
      | 'billing'
      | 'user'
      | 'parent_service'
      | 'stuck_crashlooping'
      | 'hipaa_enablement'
      | 'unknown';
    /** @enum {string} */
    deployStatus:
      | 'created'
      | 'queued'
      | 'build_in_progress'
      | 'update_in_progress'
      | 'live'
      | 'deactivated'
      | 'build_failed'
      | 'update_failed'
      | 'canceled'
      | 'pre_deploy_in_progress'
      | 'pre_deploy_failed';
    deploy: {
      id: string;
      commit?: {
        id?: string;
        message?: string;
        /** Format: date-time */
        createdAt?: string;
      };
      /** @description Image information used when creating the deploy. Not present for Git-backed deploys */
      image?: {
        /** @description Image reference used when creating the deploy */
        ref?: string;
        /** @description SHA that the image reference was resolved to when creating the deploy */
        sha?: string;
        /** @description Name of credential used to pull the image, if provided */
        registryCredential?: string;
      };
      status?: components['schemas']['deployStatus'];
      /** @enum {string} */
      trigger?:
        | 'api'
        | 'blueprint_sync'
        | 'deploy_hook'
        | 'deployed_by_render'
        | 'manual'
        | 'other'
        | 'new_commit'
        | 'rollback'
        | 'service_resumed'
        | 'service_updated';
      /** Format: date-time */
      startedAt?: string;
      /** Format: date-time */
      finishedAt?: string;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    envVar: {
      key: string;
      value: string;
    };
    envVarWithCursor: {
      envVar: components['schemas']['envVar'];
      cursor: components['schemas']['cursor'];
    };
    customDomainWithCursor: {
      customDomain: components['schemas']['customDomain'];
      cursor: components['schemas']['cursor'];
    };
    customDomain: {
      id: string;
      name: string;
      /** @enum {string} */
      domainType: 'apex' | 'subdomain';
      publicSuffix: string;
      redirectForName: string;
      /** @enum {string} */
      verificationStatus: 'verified' | 'unverified';
      /** Format: date-time */
      createdAt: string;
      server?: {
        id?: string;
        name?: string;
      };
    };
    serverPort: {
      /** @example 10000 */
      port: number;
      /** @enum {string} */
      protocol: 'TCP' | 'UDP';
    };
    error: {
      id?: string;
      message?: string;
    };
    /**
     * @deprecated
     * @description This field has been deprecated. previews.generation should be used in its place.
     * @default no
     * @enum {string}
     */
    pullRequestPreviewsEnabled: 'yes' | 'no';
    previews: {
      /**
       * @description Defaults to "off"
       * @default off
       * @enum {string}
       */
      generation: 'off' | 'manual' | 'automatic';
    };
    /**
     * @default starter
     * @enum {string}
     */
    buildPlan: 'starter' | 'performance';
    /**
     * @description Controls whether render.com subdomains are available for the service
     * @enum {string}
     */
    renderSubdomainPolicy: 'enabled' | 'disabled';
    /** @description Input type for creating a Key Value instance */
    keyValuePOSTInput: {
      /** @description The name of the Key Value instance */
      name: string;
      /** @description The ID of the owner of the Key Value instance */
      ownerId: string;
      plan: components['schemas']['keyValuePlan'];
      /** @description The region where the Key Value instance is located */
      region?: string;
      environmentId?: string;
      maxmemoryPolicy?: components['schemas']['maxmemoryPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    /** @description Input type for updating a Key Value instance */
    keyValuePATCHInput: {
      /** @description The name of the Key Value instance */
      name?: string;
      plan?: components['schemas']['keyValuePlan'];
      maxmemoryPolicy?: components['schemas']['maxmemoryPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    /**
     * @description The eviction policy for the Key Value instance
     * @enum {string}
     */
    maxmemoryPolicy:
      | 'noeviction'
      | 'allkeys_lfu'
      | 'allkeys_lru'
      | 'allkeys_random'
      | 'volatile_lfu'
      | 'volatile_lru'
      | 'volatile_random'
      | 'volatile_ttl';
    /** @description A Key Value instance */
    keyValue: {
      /** @description The ID of the Key Value instance */
      id: string;
      /**
       * Format: date-time
       * @description The creation time of the Key Value instance
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description The last updated time of the Key Value instance
       */
      updatedAt: string;
      status: components['schemas']['databaseStatus'];
      region: components['schemas']['region'];
      plan: components['schemas']['keyValuePlan'];
      /** @description The name of the Key Value instance */
      name: string;
      owner: components['schemas']['owner'];
      options: components['schemas']['keyValueOptions'];
      /** @description The IP allow list for the Key Value instance */
      ipAllowList: components['schemas']['cidrBlockAndDescription'][];
      /** @description The ID of the environment the Key Value instance is associated with */
      environmentId?: string;
      /** @description The version of Key Value */
      version: string;
      /** @description The URL to view the Key Value instance in the Render Dashboard */
      dashboardUrl: string;
    };
    keyValueWithCursor: {
      keyValue: components['schemas']['keyValue'];
      cursor: components['schemas']['cursor'];
    };
    /** @description A Key Value instance */
    keyValueDetail: {
      /** @description The ID of the Key Value instance */
      id: string;
      /**
       * Format: date-time
       * @description The creation time of the Key Value instance
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description The last updated time of the Key Value instance
       */
      updatedAt: string;
      status: components['schemas']['databaseStatus'];
      region: components['schemas']['region'];
      plan: components['schemas']['keyValuePlan'];
      /** @description The name of the Key Value instance */
      name: string;
      owner: components['schemas']['owner'];
      options: components['schemas']['keyValueOptions'];
      /** @description The IP allow list for the Key Value instance */
      ipAllowList: components['schemas']['cidrBlockAndDescription'][];
      /** @description The ID of the environment the Key Value instance is associated with */
      environmentId?: string;
      /** @description The version of Key Value */
      version: string;
      maintenance?: components['schemas']['maintenanceRun'];
    };
    /** @description A Key Value instance */
    keyValueConnectionInfo: {
      /** @description The connection string to use from within Render */
      internalConnectionString: string;
      /**
       * Format: password
       * @description The connection string to use from outside Render
       */
      externalConnectionString: string;
      /**
       * Format: password
       * @description The CLI (redis-cli or valkey-cli) command to connect to the Key Value instance
       */
      cliCommand: string;
    };
    /** @description Options for a Key Value instance */
    keyValueOptions: {
      maxmemoryPolicy?: string;
    };
    cidrBlockAndDescription: {
      cidrBlock: string;
      /** @description User-provided description of the CIDR block */
      description: string;
    };
    /** @enum {string} */
    keyValuePlan: 'free' | 'starter' | 'standard' | 'pro' | 'pro_plus' | 'custom';
    /** @description Input type for creating a Redis instance */
    redisPOSTInput: {
      /** @description The name of the Redis instance */
      name: string;
      /** @description The ID of the owner of the Redis instance */
      ownerId: string;
      plan: components['schemas']['redisPlan'];
      /** @description The region where the Redis instance is located */
      region?: string;
      environmentId?: string;
      maxmemoryPolicy?: components['schemas']['maxmemoryPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    /** @description Input type for updating a Redis instance */
    redisPATCHInput: {
      /** @description The name of the Redis instance */
      name?: string;
      plan?: components['schemas']['redisPlan'];
      maxmemoryPolicy?: components['schemas']['maxmemoryPolicy'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    /** @description A Redis instance */
    redis: {
      /** @description The ID of the Redis instance */
      id: string;
      /**
       * Format: date-time
       * @description The creation time of the Redis instance
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description The last updated time of the Redis instance
       */
      updatedAt: string;
      status: components['schemas']['databaseStatus'];
      region: components['schemas']['region'];
      plan: components['schemas']['redisPlan'];
      /** @description The name of the Redis instance */
      name: string;
      owner: components['schemas']['owner'];
      options: components['schemas']['redisOptions'];
      /** @description The IP allow list for the Redis instance */
      ipAllowList: components['schemas']['cidrBlockAndDescription'][];
      /** @description The ID of the environment the Redis instance is associated with */
      environmentId?: string;
      /** @description The version of Redis */
      version: string;
      /** @description The URL to view the Redis instance in the Render Dashboard */
      dashboardUrl: string;
    };
    redisWithCursor: {
      redis: components['schemas']['redis'];
      cursor: components['schemas']['cursor'];
    };
    /** @description A Redis instance */
    redisDetail: {
      /** @description The ID of the Redis instance */
      id: string;
      /**
       * Format: date-time
       * @description The creation time of the Redis instance
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description The last updated time of the Redis instance
       */
      updatedAt: string;
      status: components['schemas']['databaseStatus'];
      region: components['schemas']['region'];
      plan: components['schemas']['redisPlan'];
      /** @description The name of the Redis instance */
      name: string;
      owner: components['schemas']['owner'];
      options: components['schemas']['redisOptions'];
      /** @description The IP allow list for the Redis instance */
      ipAllowList: components['schemas']['cidrBlockAndDescription'][];
      /** @description The ID of the environment the Redis instance is associated with */
      environmentId?: string;
      /** @description The version of Redis */
      version: string;
      maintenance?: components['schemas']['maintenanceRun'];
    };
    /** @description A Redis instance */
    redisConnectionInfo: {
      /** @description The connection string to use from within Render */
      internalConnectionString: string;
      /**
       * Format: password
       * @description The connection string to use from outside Render
       */
      externalConnectionString: string;
      /**
       * Format: password
       * @description The Redis CLI command to connect to the Redis instance
       */
      redisCLICommand: string;
    };
    /** @description Options for a Redis instance */
    redisOptions: {
      maxmemoryPolicy?: string;
    };
    /** @enum {string} */
    redisPlan: 'free' | 'starter' | 'standard' | 'pro' | 'pro_plus' | 'custom';
    /** @enum {string} */
    databaseStatus:
      | 'creating'
      | 'available'
      | 'unavailable'
      | 'config_restart'
      | 'suspended'
      | 'maintenance_scheduled'
      | 'maintenance_in_progress'
      | 'recovery_failed'
      | 'recovery_in_progress'
      | 'unknown'
      | 'updating_instance';
    projectWithCursor: {
      project: components['schemas']['project'];
      cursor: components['schemas']['cursor'];
    };
    /** @description A project is a collection of environments */
    project: {
      /** @description The ID of the project */
      id: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** @description The name of the project */
      name: string;
      owner: components['schemas']['owner'];
      /** @description The environments associated with the project */
      environmentIds: string[];
    };
    projectPOSTInput: {
      /** @description The name of the project */
      name: string;
      /** @description The ID of the owner that the project belongs to */
      ownerId: string;
      /** @description The environments to create when creating the project */
      environments: components['schemas']['projectPOSTEnvironmentInput'][];
    };
    /** @description Input type for updating a project */
    projectPATCHInput: {
      name?: string;
    };
    projectPOSTEnvironmentInput: {
      name: string;
      protectedStatus?: components['schemas']['protectedStatus'];
      networkIsolationEnabled?: components['schemas']['networkIsolationEnabled'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    environmentPOSTInput: {
      name: string;
      projectId: string;
      protectedStatus?: components['schemas']['protectedStatus'];
      networkIsolationEnabled?: components['schemas']['networkIsolationEnabled'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    environmentResourcesPOSTInput: {
      resourceIds: string[];
    };
    environmentPATCHInput: {
      name?: string;
      networkIsolationEnabled?: components['schemas']['networkIsolationEnabled'];
      protectedStatus?: components['schemas']['protectedStatus'];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
    };
    environment: {
      id: string;
      name: string;
      projectId: string;
      databasesIds: string[];
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      redisIds: string[];
      serviceIds: string[];
      envGroupIds: string[];
      protectedStatus: components['schemas']['protectedStatus'];
      networkIsolationEnabled: components['schemas']['networkIsolationEnabled'];
    };
    /** @description An environment with a cursor */
    environmentWithCursor: {
      environment: components['schemas']['environment'];
      cursor: components['schemas']['cursor'];
    };
    /**
     * @description Indicates whether an environment is `unprotected` or `protected`. Only admin users can perform destructive actions in `protected` environments.
     * @enum {string}
     */
    protectedStatus: 'unprotected' | 'protected';
    /** @description Indicates whether network connections across environments are allowed. */
    networkIsolationEnabled: boolean;
    envGroupPOSTInput: {
      name: string;
      ownerId: string;
      envVars: components['schemas']['envVarInputArray'];
      secretFiles?: components['schemas']['secretFileInput'][];
      serviceIds?: string[];
      environmentId?: string;
    };
    envGroupPATCHInput: {
      name: string;
    };
    secretFileInput: {
      name: string;
      content: string;
    };
    envGroup: components['schemas']['envGroupMeta'] & {
      envVars: components['schemas']['envVar'][];
      secretFiles: components['schemas']['secretFile'][];
    };
    envGroupMeta: {
      id: string;
      name: string;
      ownerId: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** @description List of serviceIds linked to the envGroup */
      serviceLinks: components['schemas']['envGroupLink'][];
      environmentId?: string;
    };
    secretFile: {
      name: string;
      content: string;
    };
    secretFileWithCursor: {
      secretFile: components['schemas']['secretFile'];
      cursor: components['schemas']['cursor'];
    };
    envGroupLink: {
      id: string;
      name: string;
      type: components['schemas']['serviceTypeShort'];
    };
    /** @description Input for creating a database */
    postgresPOSTInput: {
      /** @default randomly generated */
      databaseName: string;
      /** @default randomly generated */
      databaseUser: string;
      /** @description The Datadog API key for the Datadog agent to monitor the new database. */
      datadogAPIKey?: string;
      /**
       * @description Datadog region to use for monitoring the new database. Defaults to 'US1'.
       * @example US1
       */
      datadogSite?: string;
      /** @description The name of the database as it will appear in the Render Dashboard */
      name: string;
      /** @default false */
      enableHighAvailability: boolean;
      environmentId?: string;
      /** @description The ID of the workspace to create the database for */
      ownerId: string;
      plan: components['schemas']['postgresPlans'];
      /** @description The number of gigabytes of disk space to allocate for the database */
      diskSizeGB?: number;
      region?: string;
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      readReplicas?: components['schemas']['readReplicasInput'];
      version: components['schemas']['postgresVersion'];
    };
    postgresPATCHInput: {
      name?: string;
      plan?: components['schemas']['postgresPlans'];
      /** @description The number of gigabytes of disk space to allocate for the database */
      diskSizeGB?: number;
      enableHighAvailability?: boolean;
      /** @description The Datadog API key for the Datadog agent to monitor the database. Pass empty string to remove. Restarts Postgres on change. */
      datadogAPIKey?: string;
      /**
       * @description Datadog region to use for monitoring the new database. Defaults to 'US1'.
       * @example US1
       */
      datadogSite?: string;
      ipAllowList?: components['schemas']['cidrBlockAndDescription'][];
      readReplicas?: components['schemas']['readReplicasInput'];
    };
    readReplicas: components['schemas']['readReplica'][];
    readReplica: {
      /** @description The replica instance identifier. */
      id: string;
      /** @description The display name of the replica instance. */
      name: string;
    };
    readReplicasInput: components['schemas']['readReplicaInput'][];
    readReplicaInput: {
      /** @description The display name of the replica instance. */
      name: string;
    };
    postgresConnectionInfo: {
      /** Format: password */
      password: string;
      /** Format: password */
      internalConnectionString: string;
      /** Format: password */
      externalConnectionString: string;
      /** Format: password */
      psqlCommand: string;
    };
    postgresWithCursor: {
      postgres: components['schemas']['postgres'];
      cursor: components['schemas']['cursor'];
    };
    postgres: {
      id: string;
      ipAllowList: components['schemas']['cidrBlockAndDescription'][];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /**
       * Format: date-time
       * @description The time at which the database will be expire. Applies to free tier databases only.
       */
      expiresAt?: string;
      databaseName: string;
      databaseUser: string;
      environmentId?: string;
      highAvailabilityEnabled: boolean;
      name: string;
      owner: components['schemas']['owner'];
      plan: components['schemas']['postgresPlans'];
      diskSizeGB?: number;
      primaryPostgresID?: string;
      region: components['schemas']['region'];
      readReplicas: components['schemas']['readReplicas'];
      role: components['schemas']['databaseRole'];
      status: components['schemas']['databaseStatus'];
      version: components['schemas']['postgresVersion'];
      /** @enum {string} */
      suspended: 'suspended' | 'not_suspended';
      suspenders: components['schemas']['suspenderType'][];
      /** @description The URL to view the Postgres instance in the Render Dashboard */
      dashboardUrl: string;
    };
    postgresDetail: {
      id: string;
      ipAllowList: components['schemas']['cidrBlockAndDescription'][];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /**
       * Format: date-time
       * @description The time at which the database will be expire. Applies to free tier databases only.
       */
      expiresAt?: string;
      /** @description The URL to view the Postgres instance in the Render Dashboard */
      dashboardUrl: string;
      databaseName: string;
      databaseUser: string;
      environmentId?: string;
      highAvailabilityEnabled: boolean;
      maintenance?: components['schemas']['maintenanceRun'];
      name: string;
      owner: components['schemas']['owner'];
      plan: components['schemas']['postgresPlans'];
      diskSizeGB?: number;
      primaryPostgresID?: string;
      region: components['schemas']['region'];
      readReplicas: components['schemas']['readReplicas'];
      role: components['schemas']['databaseRole'];
      status: components['schemas']['databaseStatus'];
      version: components['schemas']['postgresVersion'];
      /** @enum {string} */
      suspended: 'suspended' | 'not_suspended';
      suspenders: components['schemas']['suspenderType'][];
    };
    /**
     * @description The PostgreSQL version
     * @enum {string}
     */
    postgresVersion: '11' | '12' | '13' | '14' | '15' | '16' | '17';
    /** @enum {string} */
    databaseRole: 'primary' | 'replica';
    /**
     * @description Defaults to "starter"
     * @default starter
     * @enum {string}
     */
    paidPlan: 'starter' | 'standard' | 'pro' | 'pro_plus' | 'pro_max' | 'pro_ultra';
    /** @description A run of a cron job */
    cronJobRun: {
      /** @description The ID of the run */
      id: string;
      /** @enum {string} */
      status: 'pending' | 'successful' | 'unsuccessful' | 'canceled';
      /**
       * Format: date-time
       * @example 2021-07-15T07:20:05.777035-07:00
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @example 2021-07-15T07:20:05.777035-07:00
       */
      finishedAt?: string;
      /** @description user who triggered the cron job run */
      triggeredBy?: string;
      /** @description user who cancelled the cron job run */
      canceledBy?: string;
    };
    /** @description A Blueprint with a cursor */
    blueprintWithCursor: {
      blueprint: components['schemas']['blueprint'];
      cursor: components['schemas']['cursor'];
    };
    /** @description A Blueprint sync with a cursor */
    syncWithCursor: {
      sync: components['schemas']['sync'];
      cursor: components['schemas']['cursor'];
    };
    /** @description A service event with a cursor */
    serviceEventWithCursor: {
      event: components['schemas']['serviceEvent'];
    };
    jobWithCursor: {
      job: components['schemas']['job'];
      cursor: components['schemas']['cursor'];
    };
    user: {
      email: string;
      name: string;
    };
    webhookWithCursor: {
      webhook: components['schemas']['webhook'];
      cursor: components['schemas']['cursor'];
    };
    webhookEventWithCursor: {
      webhookEvent: components['schemas']['webhookEvent'];
      cursor: components['schemas']['cursor'];
    };
    serviceInstance: {
      id: string;
      /** Format: date-time */
      createdAt: string;
    };
    /** @example exs-cph1rs3idesc73a2b2mg */
    blueprintId: string;
    /** @enum {string} */
    status: 'created' | 'paused' | 'in_sync' | 'syncing' | 'error';
    /** @description Automatically sync changes to render.yaml */
    autoSync: boolean;
    blueprint: {
      id: components['schemas']['blueprintId'];
      name: string;
      status: components['schemas']['status'];
      autoSync: components['schemas']['autoSync'];
      repo: string;
      branch: string;
      /** Format: date-time */
      lastSync?: string;
    };
    resourceRef: {
      id: string;
      name: string;
      /**
       * @description type of the resource (ex. web_service or postgres)
       * @enum {string}
       */
      type:
        | 'static_site'
        | 'web_service'
        | 'private_service'
        | 'background_worker'
        | 'cron_job'
        | 'redis'
        | 'key_value'
        | 'postgres'
        | 'environment_group';
    };
    blueprintDetail: {
      id: components['schemas']['blueprintId'];
      name: string;
      status: components['schemas']['status'];
      autoSync: components['schemas']['autoSync'];
      repo: string;
      branch: string;
      /** Format: date-time */
      lastSync?: string;
      resources: components['schemas']['resourceRef'][];
    };
    blueprintPATCH: {
      name?: string;
      autoSync?: components['schemas']['autoSync'];
    };
    /** @example exe-cph1rs3idesc73a2b2mg */
    syncId: string;
    commitRef: {
      id: string;
    };
    /** @enum {string} */
    syncState: 'created' | 'pending' | 'running' | 'error' | 'success';
    sync: {
      id: components['schemas']['syncId'];
      commit: components['schemas']['commitRef'];
      /** Format: date-time */
      startedAt?: string;
      /** Format: date-time */
      completedAt?: string;
      state: components['schemas']['syncState'];
    };
    /** @example dsk-cph1rs3idesc73a2b2mg */
    diskId: string;
    diskDetails: {
      id: components['schemas']['diskId'];
      name: string;
      sizeGB: number;
      mountPath: string;
      serviceId?: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    diskPOST: {
      name: string;
      sizeGB: number;
      mountPath: string;
      serviceId: string;
    };
    diskPATCH: {
      name?: string;
      sizeGB?: number;
      mountPath?: string;
    };
    /** @enum {string} */
    notifySettingV2: 'none' | 'failure' | 'all';
    notificationSetting: {
      ownerId: string;
      slackEnabled: boolean;
      emailEnabled: boolean;
      previewNotificationsEnabled: boolean;
      notificationsToSend: components['schemas']['notifySettingV2'];
    };
    notificationSettingPATCH: {
      emailEnabled?: boolean;
      previewNotificationsEnabled?: boolean;
      notificationsToSend?: components['schemas']['notifySettingV2'];
    };
    /** @enum {string} */
    notifyPreviewOverride: 'default' | 'false' | 'true';
    /** @enum {string} */
    notifyOverride: 'default' | 'none' | 'failure' | 'all';
    notificationOverride: {
      serviceId: string;
      previewNotificationsEnabled: components['schemas']['notifyPreviewOverride'];
      notificationsToSend: components['schemas']['notifyOverride'];
    };
    notificationServiceOverride: {
      serviceId: string;
      previewNotificationsEnabled: components['schemas']['notifyPreviewOverride'];
      notificationsToSend: components['schemas']['notifyOverride'];
    };
    notificationServiceOverridePATCH: {
      previewNotificationsEnabled?: components['schemas']['notifyPreviewOverride'];
      notificationsToSend?: components['schemas']['notifyOverride'];
    };
    autoscalingCriteriaPercentage: {
      /** @default false */
      enabled: boolean;
      /** @description Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances. */
      percentage: number;
    };
    autoscalingCriteria: {
      cpu: components['schemas']['autoscalingCriteriaPercentage'];
      memory: components['schemas']['autoscalingCriteriaPercentage'];
    };
    autoscalingConfig: {
      /** @default false */
      enabled: boolean;
      /** @description The minimum number of instances for the service */
      min: number;
      /** @description The maximum number of instances for the service */
      max: number;
      criteria: components['schemas']['autoscalingCriteria'];
    };
    disk: {
      id: components['schemas']['diskId'];
      name: string;
      sizeGB: number;
      mountPath: string;
    };
    /** @enum {string} */
    serviceEventType:
      | 'autoscaling_config_changed'
      | 'autoscaling_ended'
      | 'autoscaling_started'
      | 'branch_deleted'
      | 'build_ended'
      | 'build_started'
      | 'commit_ignored'
      | 'cron_job_run_ended'
      | 'cron_job_run_started'
      | 'deploy_ended'
      | 'deploy_started'
      | 'disk_created'
      | 'disk_updated'
      | 'disk_deleted'
      | 'image_pull_failed'
      | 'initial_deploy_hook_ended'
      | 'initial_deploy_hook_started'
      | 'instance_count_changed'
      | 'job_run_ended'
      | 'maintenance_mode_enabled'
      | 'maintenance_mode_uri_updated'
      | 'maintenance_ended'
      | 'maintenance_started'
      | 'pipeline_minutes_exhausted'
      | 'plan_changed'
      | 'pre_deploy_ended'
      | 'pre_deploy_started'
      | 'server_available'
      | 'server_failed'
      | 'server_hardware_failure'
      | 'server_restarted'
      | 'service_resumed'
      | 'service_suspended'
      | 'suspender_added'
      | 'suspender_removed'
      | 'zero_downtime_redeploy_ended'
      | 'zero_downtime_redeploy_started';
    /** @example evt-cph1rs3idesc73a2b2mg */
    eventId: string;
    /** Autoscaling Config Changed */
    autoscalingConfigChangedEvent: {
      fromConfig?: components['schemas']['autoscalingConfig'];
      toConfig: components['schemas']['autoscalingConfig'];
    };
    /** Autoscaling Ended */
    autoscalingEndedEvent: {
      fromInstances: number;
      toInstances: number;
    };
    /** Autoscaling Started */
    autoscalingStartedEvent: {
      fromInstances: number;
      toInstances: number;
      currentCPU?: number;
      targetCPU?: number;
      currentMemory?: number;
      targetMemory?: number;
    };
    /** Branch Deleted */
    branchDeletedEvent: {
      deletedBranch: string;
      newBranch: string;
    };
    /** @enum {string} */
    eventStatus: 'succeeded' | 'failed' | 'canceled';
    buildDeployEndReasonID: {
      id: string;
    };
    oomKilled: {
      memoryLimit: string;
    };
    failureReason: {
      evicted: boolean;
      /** @description If present, the application exited with the specified non-zero status. */
      nonZeroExit?: number;
      /** @description If true, the application exited early. Services besides cron jobs should not exit unless receiving a `SIGTERM` signal from Render. */
      earlyExit?: boolean;
      oomKilled?: components['schemas']['oomKilled'];
      /** Format: int64 */
      timedOutSeconds?: number;
      unhealthy?: string;
      timedOutReason?: string;
    };
    buildDeployEndReason: {
      buildFailed?: components['schemas']['buildDeployEndReasonID'];
      newBuild?: components['schemas']['buildDeployEndReasonID'];
      newDeploy?: components['schemas']['buildDeployEndReasonID'];
      failure?: components['schemas']['failureReason'];
    };
    /** Build Ended */
    buildEndedEvent: {
      buildId: string;
      buildStatus: components['schemas']['eventStatus'];
      reason: components['schemas']['buildDeployEndReason'];
      /** @deprecated */
      status: number;
    };
    /** @description User who triggered the action */
    'schemas-user': {
      id: string;
      email: string;
    };
    buildDeployTrigger: {
      /** @description Deploy was triggered by service creation */
      firstBuild: boolean;
      /** @description Deploy was triggered by an environment update */
      envUpdated: boolean;
      /** @description Deploy was triggered manually from the dashboard */
      manual: boolean;
      user?: components['schemas']['schemas-user'];
      /** @description Updated property that triggered the deploy */
      updatedProperty?: string;
      /** @description Commit that triggered the deploy */
      newCommit?: string;
      /** @description Deploy was triggered by Render */
      deployedByRender: boolean;
      /** @description Whether the cache was cleared for the deploy */
      clearCache: boolean;
      /** @description Whether the deploy was triggered by a rollback */
      rollback: boolean;
      /** @description Deploy ID that was rolled back to */
      rollbackTargetDeployId?: string;
    };
    /** Build Started */
    buildStartedEvent: {
      buildId: string;
      trigger: components['schemas']['buildDeployTrigger'];
    };
    /** Commit Ignored */
    commitIgnoredEvent: {
      /** @description the commit id */
      id: string;
      /** @description the commit url */
      url: string;
    };
    /** @enum {string} */
    cronJobRunStatus: 'canceled' | 'pending' | 'successful' | 'unsuccessful';
    /** Cron Job Run Ended */
    cronJobRunEndedEvent: {
      cronJobRunId: string;
      status: components['schemas']['cronJobRunStatus'];
      reason?: components['schemas']['failureReason'];
      user?: components['schemas']['schemas-user'];
    };
    /** Cron Job Run Started */
    cronJobRunStartedEvent: {
      cronJobRunId: string;
    };
    /** Deploy Ended */
    deployEndedEvent: {
      deployId: string;
      reason: components['schemas']['buildDeployEndReason'];
      deployStatus: components['schemas']['eventStatus'];
      /** @deprecated */
      status: number;
    };
    /** Deploy Started */
    deployStartedEvent: {
      deployId: string;
      trigger: components['schemas']['buildDeployTrigger'];
    };
    /** Disk Created */
    diskCreatedEvent: {
      diskId: components['schemas']['diskId'];
      sizeGB: number;
    };
    /** Disk Updated */
    diskUpdatedEvent: {
      diskId: components['schemas']['diskId'];
      fromSizeGB: number;
      toSizeGB: number;
    };
    /** Disk Deleted */
    diskDeletedEvent: {
      diskId: components['schemas']['diskId'];
    };
    /** Image Pull Failed */
    imagePullFailedEvent: {
      message: string;
      imageURL: string;
    };
    /** Initial Deploy Hook Started */
    initialDeployHookStartedEvent: {
      deployId: string;
    };
    /** Initial Deploy Hook Ended */
    initialDeployHookEndedEvent: {
      deployId: string;
    };
    /** Instance Count Changed */
    instanceCountChangedEvent: {
      fromInstances: number;
      toInstances: number;
    };
    /** @example job-cph1rs3idesc73a2b2mg */
    jobId: string;
    /** @enum {string} */
    jobStatus: 'pending' | 'running' | 'succeeded' | 'failed' | 'canceled';
    /** Job Run Ended */
    jobRunEndedEvent: {
      jobId: components['schemas']['jobId'];
      status: components['schemas']['jobStatus'];
      reason?: components['schemas']['failureReason'];
    };
    /** Maintenance Mode Enabled */
    maintenanceModeEnabledEvent: {
      enabled: boolean;
    };
    /** Maintenance Mode URI Updated */
    maintenanceModeURIUpdatedEvent: {
      fromURI: string;
      toURI: string;
    };
    /** Maintenance Ended */
    maintenanceEndedEvent: Record<string, never>;
    maintenanceTrigger: {
      user?: components['schemas']['schemas-user'];
      /** @description Maintenance was triggered manually */
      manual: boolean;
      /** @description Maintenance was triggered by Render */
      startedByRender: boolean;
    };
    /** Maintenance Started */
    maintenanceStartedEvent: {
      trigger: components['schemas']['maintenanceTrigger'];
    };
    /** Pipeline Minutes Exhausted */
    pipelineMinutesExhaustedEvent: {
      buildId: string;
      trigger: components['schemas']['buildDeployTrigger'];
    };
    /** Instance Type Changed */
    planChangedEvent: {
      from: string;
      to: string;
    };
    /** Pre Deploy Ended */
    preDeployEndedEvent: {
      deployCommandExecutionId: string;
      deployId: string;
      preDeployStatus: components['schemas']['eventStatus'];
      reason: components['schemas']['buildDeployEndReason'];
      /** @deprecated */
      status: number;
    };
    /** Pre Deploy Started */
    preDeployStartedEvent: {
      deployCommandExecutionId: string;
      deployId: string;
    };
    /** Server Available */
    serverAvailableEvent: Record<string, never>;
    /** @example srv-d0cjkelq67qs70c2pugg-sbpkm */
    'schemas-instanceId': string;
    /** Server Failed */
    serverFailedEvent: {
      instanceID?: components['schemas']['schemas-instanceId'];
      reason?: components['schemas']['failureReason'];
    };
    /** Server Hardware Failure */
    serverHardwareFailureEvent: Record<string, never>;
    /** Server Restarted */
    serverRestartedEvent: {
      triggeredByUser: string | null;
    };
    /** Service Resumed */
    serviceResumedEvent: Record<string, never>;
    /** Service Suspended */
    serviceSuspendedEvent: Record<string, never>;
    /** Suspender Added */
    suspenderAddedEvent: {
      actor: string;
      suspendedByUser?: components['schemas']['schemas-user'];
    };
    /** Suspender Removed */
    suspenderRemovedEvent: {
      actor: string;
      resumedByUser?: components['schemas']['schemas-user'];
    };
    /** Zero Downtime Redeploy Ended */
    zeroDowntimeRedeployEndedEvent: Record<string, never>;
    /** Zero Downtime Redeploy Started */
    zeroDowntimeRedeployStartedEvent: {
      trigger: string;
    };
    edgeCacheTrigger: {
      /** @description Edge Cache change was triggered manually from the dashboard */
      manual: boolean;
      user?: components['schemas']['schemas-user'];
      /** @description Edge Cache Change was triggered by Render */
      system: boolean;
    };
    /** Edge Cache Disabled */
    edgeCacheDisabledEvent: {
      trigger: components['schemas']['edgeCacheTrigger'];
    };
    /** Edge Cache Enabled */
    edgeCacheEnabledEvent: {
      trigger: components['schemas']['edgeCacheTrigger'];
    };
    /** Edge Cache Purged */
    edgeCachePurgedEvent: {
      trigger: components['schemas']['edgeCacheTrigger'];
    };
    /** Service Event Details */
    serviceEventDetails:
      | components['schemas']['autoscalingConfigChangedEvent']
      | components['schemas']['autoscalingEndedEvent']
      | components['schemas']['autoscalingStartedEvent']
      | components['schemas']['branchDeletedEvent']
      | components['schemas']['buildEndedEvent']
      | components['schemas']['buildStartedEvent']
      | components['schemas']['commitIgnoredEvent']
      | components['schemas']['cronJobRunEndedEvent']
      | components['schemas']['cronJobRunStartedEvent']
      | components['schemas']['deployEndedEvent']
      | components['schemas']['deployStartedEvent']
      | components['schemas']['diskCreatedEvent']
      | components['schemas']['diskUpdatedEvent']
      | components['schemas']['diskDeletedEvent']
      | components['schemas']['imagePullFailedEvent']
      | components['schemas']['initialDeployHookStartedEvent']
      | components['schemas']['initialDeployHookEndedEvent']
      | components['schemas']['instanceCountChangedEvent']
      | components['schemas']['jobRunEndedEvent']
      | components['schemas']['maintenanceModeEnabledEvent']
      | components['schemas']['maintenanceModeURIUpdatedEvent']
      | components['schemas']['maintenanceEndedEvent']
      | components['schemas']['maintenanceStartedEvent']
      | components['schemas']['pipelineMinutesExhaustedEvent']
      | components['schemas']['planChangedEvent']
      | components['schemas']['preDeployEndedEvent']
      | components['schemas']['preDeployStartedEvent']
      | components['schemas']['serverAvailableEvent']
      | components['schemas']['serverFailedEvent']
      | components['schemas']['serverHardwareFailureEvent']
      | components['schemas']['serverRestartedEvent']
      | components['schemas']['serviceResumedEvent']
      | components['schemas']['serviceSuspendedEvent']
      | components['schemas']['suspenderAddedEvent']
      | components['schemas']['suspenderRemovedEvent']
      | components['schemas']['zeroDowntimeRedeployEndedEvent']
      | components['schemas']['zeroDowntimeRedeployStartedEvent']
      | components['schemas']['edgeCacheDisabledEvent']
      | components['schemas']['edgeCacheEnabledEvent']
      | components['schemas']['edgeCachePurgedEvent'];
    serviceEvent: {
      id: components['schemas']['eventId'];
      /** Format: date-time */
      timestamp: string;
      serviceId: string;
      type: components['schemas']['serviceEventType'];
      details: components['schemas']['serviceEventDetails'];
    };
    job: {
      id: components['schemas']['jobId'];
      /** @example srv-xxxxx */
      serviceId: string;
      /** @example echo 'hello world' */
      startCommand: string;
      /** @example plan-srv-004 */
      planId: string;
      status?: components['schemas']['jobStatus'];
      /**
       * Format: date-time
       * @example 2021-07-15T07:20:05.777035-07:00
       */
      createdAt: string;
      /**
       * Format: date-time
       * @example 2021-07-15T07:20:05.777035-07:00
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @example 2021-07-15T07:20:05.777035-07:00
       */
      finishedAt?: string;
    };
    /** @enum {string} */
    eventType:
      | 'autoscaling_config_changed'
      | 'autoscaling_ended'
      | 'autoscaling_started'
      | 'branch_deleted'
      | 'build_ended'
      | 'build_started'
      | 'commit_ignored'
      | 'cron_job_run_ended'
      | 'cron_job_run_started'
      | 'deploy_ended'
      | 'deploy_started'
      | 'disk_created'
      | 'disk_updated'
      | 'disk_deleted'
      | 'image_pull_failed'
      | 'instance_count_changed'
      | 'job_run_ended'
      | 'maintenance_mode_enabled'
      | 'maintenance_mode_uri_updated'
      | 'maintenance_ended'
      | 'maintenance_started'
      | 'pipeline_minutes_exhausted'
      | 'plan_changed'
      | 'pre_deploy_ended'
      | 'pre_deploy_started'
      | 'server_available'
      | 'server_failed'
      | 'server_hardware_failure'
      | 'server_restarted'
      | 'service_resumed'
      | 'service_suspended'
      | 'zero_downtime_redeploy_ended'
      | 'zero_downtime_redeploy_started'
      | 'edge_cache_enabled'
      | 'edge_cache_disabled'
      | 'edge_cache_purged'
      | 'postgres_available'
      | 'postgres_backup_completed'
      | 'postgres_backup_failed'
      | 'postgres_backup_started'
      | 'postgres_cluster_leader_changed'
      | 'postgres_created'
      | 'postgres_disk_size_changed'
      | 'postgres_ha_status_changed'
      | 'postgres_restarted'
      | 'postgres_unavailable'
      | 'postgres_upgrade_failed'
      | 'postgres_upgrade_started'
      | 'postgres_upgrade_succeeded'
      | 'postgres_restore_failed'
      | 'postgres_restore_succeeded'
      | 'postgres_read_replicas_changed'
      | 'postgres_pitr_checkpoint_started'
      | 'postgres_pitr_checkpoint_failed'
      | 'postgres_pitr_checkpoint_completed'
      | 'postgres_read_replica_stale'
      | 'postgres_wal_archive_failed'
      | 'key_value_available'
      | 'key_value_config_restart'
      | 'key_value_unhealthy';
    /** Postgres Available */
    postgresAvailableEvent: Record<string, never>;
    /** Postgres Backup Completed */
    postgresBackupCompletedEvent: Record<string, never>;
    /** Postgres Backup Failed */
    postgresBackupFailedEvent: Record<string, never>;
    /** Postgres Backup Started */
    postgresBackupStartedEvent: Record<string, never>;
    /** Postgres Cluster Leader Changed */
    postgresClusterLeaderChangedEvent: {
      leaderId?: string;
    };
    /** Postgres Created */
    postgresCreatedEvent: {
      user?: components['schemas']['schemas-user'];
    };
    /** Postgres Disk Size Changed */
    postgresDiskSizeChangedEvent: {
      user?: components['schemas']['schemas-user'];
      fromDiskSize: number;
      toDiskSize: number;
    };
    /** Postgres HA Status Changed */
    postgresHaStatusChangedEvent: {
      fromStatus: string;
      toStatus: string;
    };
    /** Postgres Read Replicas Changed */
    postgresReadReplicasChangedEvent: {
      fromReplicas: number;
      toReplicas: number;
    };
    /** Postgres Restarted */
    postgresRestartedEvent: {
      user?: components['schemas']['schemas-user'];
    };
    /** Postgres Unavailable */
    postgresUnavailableEvent: Record<string, never>;
    /** Postgres Upgrade Failed */
    postgresUpgradeFailedEvent: {
      fromVersion: string;
      toVersion: string;
    };
    /** Postgres Upgrade Started */
    postgresUpgradeStartedEvent: {
      user?: components['schemas']['schemas-user'];
      fromVersion: string;
      toVersion: string;
    };
    /** Postgres Upgrade Succeeded */
    postgresUpgradeSucceededEvent: {
      fromVersion: string;
      toVersion: string;
    };
    /** Postgres PITR Checkpoint Started */
    postgresPITRCheckpointStartedEvent: Record<string, never>;
    /** Postgres PITR Checkpoint Failed */
    postgresPITRCheckpointFailedEvent: Record<string, never>;
    /** Postgres PITR Checkpoint Completed */
    postgresPITRCheckpointCompletedEvent: Record<string, never>;
    /** Postgres Read Replica Stale */
    postgresReadReplicaStale: Record<string, never>;
    /** Postgres Event Details */
    postgresEventDetails:
      | components['schemas']['postgresAvailableEvent']
      | components['schemas']['postgresBackupCompletedEvent']
      | components['schemas']['postgresBackupFailedEvent']
      | components['schemas']['postgresBackupStartedEvent']
      | components['schemas']['postgresClusterLeaderChangedEvent']
      | components['schemas']['postgresCreatedEvent']
      | components['schemas']['postgresDiskSizeChangedEvent']
      | components['schemas']['postgresHaStatusChangedEvent']
      | components['schemas']['postgresReadReplicasChangedEvent']
      | components['schemas']['postgresRestartedEvent']
      | components['schemas']['postgresUnavailableEvent']
      | components['schemas']['postgresUpgradeFailedEvent']
      | components['schemas']['postgresUpgradeStartedEvent']
      | components['schemas']['postgresUpgradeSucceededEvent']
      | components['schemas']['postgresPITRCheckpointStartedEvent']
      | components['schemas']['postgresPITRCheckpointFailedEvent']
      | components['schemas']['postgresPITRCheckpointCompletedEvent']
      | components['schemas']['postgresReadReplicaStale'];
    /** Key Value Available */
    keyValueAvailableEvent: Record<string, never>;
    /** Key Value Config Restart */
    keyValueConfigRestartEvent: {
      reason: string;
      message: string;
    };
    /** Key Value Unhealthy */
    keyValueUnhealthyEvent: Record<string, never>;
    /** Key Value Event Details */
    keyValueEventDetails:
      | components['schemas']['keyValueAvailableEvent']
      | components['schemas']['keyValueConfigRestartEvent']
      | components['schemas']['keyValueUnhealthyEvent'];
    eventDetails:
      | components['schemas']['serviceEventDetails']
      | components['schemas']['postgresEventDetails']
      | components['schemas']['keyValueEventDetails'];
    event: {
      id: components['schemas']['eventId'];
      /** Format: date-time */
      timestamp: string;
      serviceId: string;
      type: components['schemas']['eventType'];
      details: components['schemas']['eventDetails'];
    };
    /** @enum {string} */
    logDirection: 'forward' | 'backward';
    /** @enum {string} */
    logLabelName:
      | 'resource'
      | 'instance'
      | 'host'
      | 'statusCode'
      | 'method'
      | 'level'
      | 'workflowService'
      | 'workflowVeresion'
      | 'task'
      | 'taskRun'
      | 'type'
      | 'text'
      | 'path'
      | 'blocked';
    /** @description A log label */
    logLabel: {
      /** @description The name of the log label */
      name: components['schemas']['logLabelName'];
      /** @description The value of the log label */
      value: string;
    };
    /** @description A log entry with metadata */
    log: {
      /** @description A unique ID of the log entry */
      id: string;
      /** @description The message of the log entry */
      message: string;
      /**
       * Format: date-time
       * @description The timestamp of the log entry
       */
      timestamp: string;
      labels: components['schemas']['logLabel'][];
    };
    /**
     * @description Whether to send logs or drop them.
     * @enum {string}
     */
    logStreamPreviewSetting: 'send' | 'drop';
    /** @description Owner log stream settings */
    ownerLogStreamSetting: {
      /** @description The ID of the owner. */
      ownerId?: string;
      /** @description The endpoint to stream logs to. */
      endpoint?: string;
      preview?: components['schemas']['logStreamPreviewSetting'];
    };
    /** @description The endpoint to stream logs to. */
    logStreamEndpoint: string;
    /** @description The optional token to authenticate the log stream. */
    logStreamToken: string;
    logStreamOwnerUpdate: {
      endpoint?: components['schemas']['logStreamEndpoint'];
      token?: components['schemas']['logStreamToken'];
      preview: components['schemas']['logStreamPreviewSetting'];
    };
    /**
     * @description Whether to send logs or drop them.
     * @enum {string}
     */
    logStreamSetting: 'send' | 'drop';
    /** @description Resource log stream overrides */
    resourceLogStreamSetting: {
      /** @description The ID of the resource. */
      resourceId?: string;
      /** @description The endpoint to stream logs to. Must be present if setting is send. Cannot be present if setting is drop. */
      endpoint?: string;
      setting?: components['schemas']['logStreamSetting'];
    };
    logStreamResourceUpdate: {
      endpoint?: components['schemas']['logStreamEndpoint'];
      token?: components['schemas']['logStreamToken'];
      setting: components['schemas']['logStreamSetting'];
    };
    /**
     * @description Provider to send metrics to
     * @enum {string}
     */
    otelProviderType: 'BETTER_STACK' | 'GRAFANA' | 'DATADOG' | 'NEW_RELIC' | 'HONEYCOMB' | 'CUSTOM';
    metricsStream: {
      /** @description The ID of the owner */
      ownerId: string;
      provider: components['schemas']['otelProviderType'];
      /** @description The endpoint URL to stream metrics to */
      url: string;
    };
    /** @description Input for creating or updating a metrics stream */
    metricsStreamInput: {
      provider?: components['schemas']['otelProviderType'];
      /** @description The endpoint URL to stream metrics to */
      url?: string;
      /** @description Authentication token for the metrics stream */
      token?: string;
    };
    /** @description A time series datapoint label */
    label: {
      /** @example service */
      field: string;
      /** @example srv-xxxxx */
      value: string;
    };
    /** @description A time series datapoint value */
    timeSeriesValue: {
      /**
       * Format: date-time
       * @example 2021-06-17T08:15:30Z
       */
      timestamp: string;
      /** @example 1 */
      value: number;
    };
    /** @example GB */
    unit: string;
    /** @description A time series data point */
    timeSeries: {
      /** @description List of labels describing the time series */
      labels: components['schemas']['label'][];
      /** @description The values of the time series */
      values: components['schemas']['timeSeriesValue'][];
      unit: components['schemas']['unit'];
    };
    /** @description A collection of time series */
    timeSeriesCollection: components['schemas']['timeSeries'][];
    /** @description A collection of filter values for application metrics */
    filterApplicationValuesCollection: {
      /** @enum {string} */
      filter?: 'instance';
      values?: string[];
    }[];
    /** @description A collection of filter values for HTTP metrics */
    filterHTTPValuesCollection: {
      /** @enum {string} */
      filter?: 'host' | 'statusCode';
      values?: string[];
    }[];
    /** @description A collection of suggested paths to filter by */
    filterPathValuesCollection: string[];
    /** @example mrn-cph1rs3idesc73a2b2mg */
    maintenanceRunId: string;
    /** @enum {string} */
    maintenanceState:
      | 'scheduled'
      | 'in_progress'
      | 'user_fix_required'
      | 'cancelled'
      | 'succeeded'
      | 'failed';
    maintenanceRun: {
      id: components['schemas']['maintenanceRunId'];
      type: string;
      /** Format: date-time */
      scheduledAt: string;
      /**
       * Format: date-time
       * @description If present, the maintenance run cannot be scheduled for later than this date-time.
       */
      pendingMaintenanceBy?: string;
      state: components['schemas']['maintenanceState'];
    };
    /** @enum {string} */
    postgresPlans:
      | 'free'
      | 'starter'
      | 'standard'
      | 'pro'
      | 'pro_plus'
      | 'custom'
      | 'basic_256mb'
      | 'basic_1gb'
      | 'basic_4gb'
      | 'pro_4gb'
      | 'pro_8gb'
      | 'pro_16gb'
      | 'pro_32gb'
      | 'pro_64gb'
      | 'pro_128gb'
      | 'pro_192gb'
      | 'pro_256gb'
      | 'pro_384gb'
      | 'pro_512gb'
      | 'accelerated_16gb'
      | 'accelerated_32gb'
      | 'accelerated_64gb'
      | 'accelerated_128gb'
      | 'accelerated_256gb'
      | 'accelerated_384gb'
      | 'accelerated_512gb'
      | 'accelerated_768gb'
      | 'accelerated_1024gb';
    recoveryInfo: {
      /**
       * @description Availability of point-in-time recovery.
       * @enum {string}
       */
      recoveryStatus: 'AVAILABLE' | 'BACKUP_NOT_READY' | 'NOT_AVAILABLE';
      /** Format: date-time */
      startsAt?: string;
    };
    recoveryInput: {
      /** @description Name of the new database. */
      restoreName?: string;
      /**
       * Format: date-time
       * @description The point in time to restore the database to. See `/recovery-info` for restore availability
       */
      restoreTime: string;
      /** @description Datadog API key to use for monitoring the new database. Defaults to the API key of the original database. Use an empty string to prevent copying of the API key to the new database. */
      datadogApiKey?: string;
      /** @description Datadog region code to use for monitoring the new database. Defaults to the region code of the original database. Use an empty string to prevent copying of the region code to the new database. */
      datadogSite?: string;
      /** @description The plan to use for the new database. Defaults to the same plan as the original database. Cannot be a lower tier plan than the original database. */
      plan?: string;
      /** @description The environment to create the new database in. Defaults to the environment of the original database. */
      environmentId?: string;
    };
    postgresExport: {
      id: string;
      /** Format: date-time */
      createdAt: string;
      /** @description URL to download the Postgres export */
      url?: string;
    };
    /** @description The Id of a resource that can undergo maintenance (Id of a service, a Postgres instance, or a Redis instance) */
    maintenanceResourceId: string;
    maintenanceRunWithResource: {
      id: components['schemas']['maintenanceRunId'];
      type: string;
      /** Format: date-time */
      scheduledAt: string;
      /**
       * Format: date-time
       * @description If present, the maintenance run cannot be scheduled for later than this date-time.
       */
      pendingMaintenanceBy?: string;
      state: components['schemas']['maintenanceState'];
      resourceId: components['schemas']['maintenanceResourceId'];
    };
    maintenanceRunPATCH: {
      /**
       * Format: date-time
       * @description The date-time at which the maintenance is scheduled to start. This must be before the pendingMaintenanceBy date-time.
       */
      scheduledAt?: string;
    };
    /** @example whk-d04m9b1r0fns73ckp94f */
    webhookId: string;
    /** @description The event types that will trigger the webhook. An empty list means all event types will trigger the webhook. */
    eventFilter: components['schemas']['eventType'][];
    webhook: {
      id: components['schemas']['webhookId'];
      url: string;
      name: string;
      secret: string;
      enabled: boolean;
      eventFilter: components['schemas']['eventFilter'];
    };
    webhookPOSTInput: {
      /** @description The ID of the owner (team or personal user) whose resources should be returned */
      ownerId: string;
      url: string;
      name: string;
      enabled: boolean;
      eventFilter: components['schemas']['eventFilter'];
    };
    webhookPATCHInput: {
      name?: string;
      url?: string;
      enabled?: boolean;
      eventFilter?: components['schemas']['eventFilter'];
    };
    webhookEvent: {
      /** @description the id of the webhook event */
      id: string;
      /** @description the id of the event that triggered the webhook */
      eventId: string;
      eventType: components['schemas']['eventType'];
      /** Format: date-time */
      sentAt: string;
      statusCode?: number;
      responseBody?: string;
      /** @description error is populated when an error occurs without a response such as a timeout */
      error?: string;
    };
    /**
     * @description The runtime environment for the workflow (e.g., node, python, etc.).
     * @enum {string}
     */
    Runtime: 'elixir' | 'go' | 'node' | 'python' | 'ruby';
    BuildConfig: {
      /** @description The branch to use for the build, if applicable. */
      branch?: string;
      /** @description The command to run to build the workflow. */
      buildCommand: string;
      /** @description The repository URL to use for the build. */
      repo: string;
      /** @description The root directory of the repository to use for the build, if applicable. */
      rootDir?: string;
      runtime: components['schemas']['Runtime'];
    };
    /**
     * @description Defaults to "oregon"
     * @default oregon
     * @enum {string}
     */
    Region: 'frankfurt' | 'oregon' | 'ohio' | 'singapore' | 'virginia';
    Workflow: {
      id: string;
      name: string;
      ownerId: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      buildConfig: components['schemas']['BuildConfig'];
      /** @description Command to run the workflow. */
      runCommand: string;
      region: components['schemas']['Region'];
      environmentId?: string;
      slug?: string;
    };
    WorkflowCreate: {
      name: string;
      ownerId: string;
      buildConfig: components['schemas']['BuildConfig'];
      /** @description The command to run the workflow */
      runCommand: string;
      region: components['schemas']['Region'];
    };
    WorkflowUpdate: {
      name?: string;
      buildConfig?: components['schemas']['BuildConfig'];
      /** @description The command to run the workflow */
      runCommand?: string;
    };
    /** @enum {string} */
    WorkflowVersionStatus:
      | 'created'
      | 'building'
      | 'registering'
      | 'build_failed'
      | 'registration_failed'
      | 'ready';
    WorkflowVersion: {
      id: string;
      workflowId: string;
      name: string;
      /** Format: date-time */
      createdAt: string;
      status: components['schemas']['WorkflowVersionStatus'];
    };
    CreateVersion: {
      workflowId: string;
      commit?: string;
    };
    Task: {
      id: string;
      name: string;
      /** Format: date-time */
      createdAt: string;
      workflowId?: string;
      workflowVersionId?: string;
    };
    /** @enum {string} */
    TaskRunStatus: 'pending' | 'running' | 'completed' | 'failed' | 'canceled';
    TaskRun: {
      id: string;
      taskId: string;
      status: components['schemas']['TaskRunStatus'];
      /** Format: date-time */
      startedAt?: string;
      /** Format: date-time */
      completedAt?: string;
      parentTaskRunId: string;
      rootTaskRunId: string;
      retries: number;
    };
    /**
     * @description Either a task ID or a workflow slug with task name and optional version name. If a version is not provided, the latest version of the task will be used.
     * @example tsk-1234, my-workflow-slug/my-task, my-workflow-slug/my-task:SHA123
     */
    TaskIdentifier: string;
    TaskData: unknown[];
    RunTask: {
      task: components['schemas']['TaskIdentifier'];
      input: components['schemas']['TaskData'];
    };
    TaskRunResult: unknown[];
    TaskRunDetails: {
      id: string;
      taskId: string;
      status: components['schemas']['TaskRunStatus'];
      results: components['schemas']['TaskRunResult'];
      /** @description Error message if the task run failed. */
      error?: string;
      /** Format: date-time */
      startedAt?: string;
      /** Format: date-time */
      completedAt?: string;
      input: components['schemas']['TaskData'];
      parentTaskRunId: string;
      rootTaskRunId: string;
      retries: number;
    };
  };
  responses: {
    /** @description The request could not be understood by the server. */
    '400BadRequest': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description Authorization information is missing or invalid. */
    '401Unauthorized': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description You must enter payment information to perform this request. */
    '402PaymentRequired': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description You do not have permissions for the requested resource. */
    '403Forbidden': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description Unable to find the requested resource. */
    '404NotFound': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description Unable to generate preferred media types as specified by Accept request header. */
    '406NotAcceptable': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description The current state of the resource conflicts with this request. */
    '409Conflict': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description The requested resource is no longer available. */
    '410Gone': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description Rate limit has been surpassed. */
    '429RateLimit': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description An unexpected server error has occurred. */
    '500InternalServerError': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description Server currently unavailable. */
    '503ServiceUnavailable': {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** @description A collection of logs with pagination metadata */
    Logs200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Ture if there are more logs to fetch */
          hasMore: boolean;
          /**
           * Format: date-time
           * @description The start time to use in the next query to fetch the next set of logs
           * @example 2021-07-15T07:20:05.777035-07:00
           */
          nextStartTime: string;
          /**
           * Format: date-time
           * @description The end time to use in the next query to fetch the next set of logs
           * @example 2021-07-15T07:20:05.777035-07:00
           */
          nextEndTime: string;
          logs: components['schemas']['log'][];
        };
      };
    };
    /** @description An array of possible values for a log label */
    LogsValues200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': string[];
      };
    };
    /** @description Owner log stream setting */
    GetOwnerLogsStreams200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ownerLogStreamSetting'];
      };
    };
    /** @description Resource log stream override */
    ResourceLogsStreams200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['resourceLogStreamSetting'][];
      };
    };
    /** @description Resource log stream override */
    GetResourceLogsStreams200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['resourceLogStreamSetting'];
      };
    };
    /** @description The metrics stream integration for the owner */
    GetMetricsStream200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['metricsStream'];
      };
    };
    /** @description A successful response */
    Metrics200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['timeSeriesCollection'];
      };
    };
    /** @description A successful response */
    MetricsFiltersApplication200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['filterApplicationValuesCollection'];
      };
    };
    /** @description A successful response */
    MetricsFiltersHTTP200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['filterHTTPValuesCollection'];
      };
    };
    /** @description A successful response */
    MetricsFiltersPath200Response: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['filterPathValuesCollection'];
      };
    };
  };
  parameters: {
    /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
    cursorParam: string;
    /** @description The ID or name of the custom domain */
    customDomainIdOrNameParam: string;
    /** @description The ID of the deploy */
    deployIdParam: string;
    /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
    limitParam: number;
    /** @description The maximum number of audit log items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
    auditLogLimitParam: number;
    /** @description The ID of the workspace to return resources for */
    ownerIdPathParam: string;
    /** @description The ID of the workspaces to return resources for */
    ownerIdParam: string[];
    /** @description The IDs of the workflows to return resources for */
    workflowIdParam: string[];
    /** @description The IDs of the workflow versions to return resources for */
    workflowVersionIdParam: string[];
    /** @description IDs of resources (server, cron job, postgres, or redis) to filter by */
    resourceIdParam: string[];
    /** @description The ID of the service */
    serviceIdParam: string;
    /** @description The ID of the cron job */
    cronJobIdParam: string;
    /** @description Filter for resources by service ID */
    serviceIdsParam: string[];
    /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
    startTimeParam: string;
    /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
    endTimeParam: string;
    /** @description Filter by name */
    nameParam: string[];
    /** @description Filter for types of services */
    serviceTypeParam: components['schemas']['serviceType'][];
    /**
     * @deprecated
     * @description Filter for environments (runtimes) of services (deprecated; use `runtime` instead)
     */
    envParam: components['schemas']['serviceRuntime'][];
    /**
     * @deprecated
     * @description Filter for environments (runtimes) of services
     */
    runtimeParam: components['schemas']['serviceRuntime'][];
    /** @description Filter by resource region */
    regionParam: components['schemas']['region'][];
    /** @description Filter resources based on whether they're suspended or not suspended */
    suspendedParam: ('suspended' | 'not_suspended')[];
    /**
     * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
     * @example 2021-06-17T08:15:30Z
     */
    createdBeforeParam: string;
    /**
     * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
     * @example 2021-02-17T08:15:30Z
     */
    createdAfterParam: string;
    /**
     * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
     * @example 2021-06-17T08:15:30Z
     */
    updatedBeforeParam: string;
    /**
     * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
     * @example 2021-06-17T08:15:30Z
     */
    updatedAfterParam: string;
    /** @description Filter for resources that belong to a project */
    projectIdParam: string[];
    /** @description Filter for resources that belong to an environment */
    environmentIdParam: string[];
    /** @description Include previews in the response */
    includePreviewsParam: boolean;
    /** @description Include replicas in the response */
    includeReplicasParam: boolean;
    /** @description Filter for resources that belong to an environment group */
    envGroupIdParam: string;
    /** @description The name of the environment variable */
    envVarKeyParam: string;
    /** @description The name of the secret file */
    secretFileNameParam: string;
    /** @description The type of event to filter to */
    eventTypeParam: components['schemas']['serviceEventType'];
    /** @description The ID of the Blueprint */
    blueprintId: components['schemas']['blueprintId'];
    /** @description Filter by disk IDs */
    diskIdQuery: components['schemas']['diskId'][];
    /** @description The ID of the disk */
    diskId: components['schemas']['diskId'];
    /** @description The ID of the job */
    jobId: components['schemas']['jobId'];
    /**
     * @description The direction to query logs for. Backward will return most recent logs first.
     *     Forward will start with the oldest logs in the time range.
     */
    logDirectionParam: components['schemas']['logDirection'];
    /** @description Filter logs by their resource. A resource is the id of a server, cronjob, job, postgres, redis, or workflow. */
    logFilterResource: string[];
    /** @description Filter logs by the instance they were emitted from. An instance is the id of a specific running server. */
    logFilterInstance: string[];
    /** @description Filter request logs by their host. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
    logFilterHost: string[];
    /** @description Filter request logs by their status code. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
    logFilterStatusCode: string[];
    /** @description Filter request logs by their requests method. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
    logFilterMethod: string[];
    /** @description Filter logs by their task(s) */
    logFilterTask: string[];
    /** @description Filter logs by their task run id(s) */
    logFilterTaskRun: string[];
    /** @description Filter logs by their severity level. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
    logFilterLevel: string[];
    /** @description Filter logs by their type. Types include `app` for application logs, `request` for request logs, and `build` for build logs. You can find the full set of types available for a query by using the `GET /logs/values` endpoint. */
    logFilterType: string[];
    /** @description Filter by the text of the logs. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
    logFilterText: string[];
    /** @description Filter request logs by their path. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
    logFilterPath: string[];
    /** @description The label to query logs for */
    logLabelParam: 'instance' | 'host' | 'statusCode' | 'method' | 'level' | 'type';
    /** @description Filter log streams by their id. */
    logStreamIdFilter: string[];
    /** @description Filter log streams by their setting. */
    logStreamSettingFilter: components['schemas']['logStreamSetting'][];
    /** @description The resolution of the returned data */
    resolutionParam: number;
    /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
    resourceQueryParam: string;
    /**
     * @deprecated
     * @description This parameter is deprecated. Please use `resource` instead
     */
    serviceQueryParam: string;
    /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
    instanceQueryParam: string;
    /** @description The aggregation method to apply to multiple time series */
    applicationMetricAggregationMethod: 'AVG' | 'MAX' | 'MIN';
    /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
    serviceResourceQueryParam: string;
    /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
    hostQueryParam: string;
    /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
    pathQueryParam: string;
    /** @description The field to aggregate by */
    httpAggregateBy: 'statusCode' | 'host';
    /** @description The quantile of latencies to fetch. When multiple quantile query params are provided, they are ORed together */
    quantile: number;
    /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources Postgres ids or Redis ids */
    datastoreResourceQueryParam: string;
    /** @description Postgres ID to query. When multiple resource query params are provided, they are ORed together */
    postgresResourceQueryParam: string;
    /** @description The status codes of HTTP requests to filter to. When multiple status code query params are provided, they are ORed together */
    httpStatusCode: string;
    maintenanceResourcesParam: components['schemas']['maintenanceResourceId'][];
    maintenanceStateParam: components['schemas']['maintenanceState'][];
    maintenanceRunParam: components['schemas']['maintenanceRunId'];
    /** @description Unique identifier for the webhook */
    webhookIdParam: components['schemas']['webhookId'];
    /**
     * @description Filter events sent before this time (specified as an ISO 8601 timestamp)
     * @example 2021-06-17T08:15:30Z
     */
    sentBeforeParam: string;
    /**
     * @description Filter for resources sent after a certain time (specified as an ISO 8601 timestamp)
     * @example 2021-02-17T08:15:30Z
     */
    sentAfterParam: string;
    /** @description The ID of the workflow */
    WorkflowIDParam: string;
    /** @description The ID of the workflow version */
    WorkflowVersionIDParam: string;
    /**
     * @description An array of either task identifiers which can be either a task ID or a workflow slug with task name and optional version. If a version is not provided, the latest version of the task will be used.
     * @example [
     *       "tsk-1234",
     *       "my-workflow-slug/my-task",
     *       "my-workflow-slug/my-task:SHA123"
     *     ]
     */
    TaskIdFilterParam: string[];
    /** @description An array of workflow version IDs */
    WorkflowVersionIDFilterParam: string[];
    /** @description An array of workflow IDs */
    WorkflowIDFilterParam: string[];
    /** @description The ID of the task */
    TaskIDParam: string;
    /** @description An array of root task IDs to filter on */
    RootTaskRunIDFilterParam: string[];
    /** @description The ID of the task run */
    TaskRunIDParam: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  'list-blueprints': {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['blueprintWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-blueprint': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the Blueprint */
        blueprintId: components['parameters']['blueprintId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['blueprintDetail'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'disconnect-blueprint': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the Blueprint */
        blueprintId: components['parameters']['blueprintId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Blueprint disconnected */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-blueprint': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the Blueprint */
        blueprintId: components['parameters']['blueprintId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['blueprintPATCH'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['blueprint'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-blueprint-syncs': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the Blueprint */
        blueprintId: components['parameters']['blueprintId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['syncWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-disks': {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter by disk IDs */
        diskId?: components['parameters']['diskIdQuery'];
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description Filter for resources by service ID */
        serviceId?: components['parameters']['serviceIdsParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['diskWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'add-disk': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['diskPOST'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['diskDetails'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-disk': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: components['parameters']['diskId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['diskDetails'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-disk': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: components['parameters']['diskId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Disk deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-disk': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: components['parameters']['diskId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['diskPATCH'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['diskDetails'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-snapshots': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['diskSnapshot'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'restore-snapshot': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the disk */
        diskId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['snapshotRestorePOST'];
      };
    };
    responses: {
      /** @description Restored */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['diskDetails'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'get-user': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['user'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-owners': {
    parameters: {
      query?: {
        /** @description Only return workspaces with one of the provided names. Only exact matches are returned. */
        name?: string[];
        /** @description Only return workspaces owned by one of the provided email addresses. */
        email?: string[];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ownerWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-owner': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the user or team */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['owner'];
        };
      };
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-owner-members': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the team */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['teamMembers'];
        };
      };
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-owner-audit-logs': {
    parameters: {
      query?: {
        /** @description Start time for filtering audit logs (ISO 8601 format) */
        startTime?: string;
        /** @description End time for filtering audit logs (ISO 8601 format) */
        endTime?: string;
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of audit log items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['auditLogLimitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the workspace to return resources for */
        ownerId: components['parameters']['ownerIdPathParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['auditLogWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-organization-audit-logs': {
    parameters: {
      query?: {
        /** @description Start time for filtering audit logs (ISO 8601 format) */
        startTime?: string;
        /** @description End time for filtering audit logs (ISO 8601 format) */
        endTime?: string;
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of audit log items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['auditLogLimitParam'];
      };
      header?: never;
      path: {
        /** @description The unique identifier of the organization */
        orgId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['auditLogWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-owner-notification-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return resources for */
        ownerId: components['parameters']['ownerIdPathParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['notificationSetting'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'patch-owner-notification-settings': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return resources for */
        ownerId: components['parameters']['ownerIdPathParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['notificationSettingPATCH'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['notificationSetting'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-notification-overrides': {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter for resources by service ID */
        serviceId?: components['parameters']['serviceIdsParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['notificationOverrideWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-service-notification-overrides': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['notificationServiceOverride'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'patch-service-notification-overrides': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['notificationServiceOverridePATCH'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['notificationServiceOverride'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-registry-credentials': {
    parameters: {
      query?: {
        /** @description Filter for the name of a credential */
        name?: string[];
        /** @description Filter for the username of a credential */
        username?: string[];
        /** @description Filter for the registry type for the credential */
        type?: components['schemas']['registryCredentialRegistry'][];
        /**
         * @description Filter for services created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: string;
        /**
         * @description Filter for services created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: string;
        /**
         * @description Filter for services updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: string;
        /**
         * @description Filter for services updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        updatedAfter?: string;
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['registryCredential'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-registry-credential': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          registry: components['schemas']['registryCredentialRegistry'];
          name: string;
          username: string;
          authToken: string;
          ownerId: string;
        };
      };
    };
    responses: {
      /** @description Created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['registryCredential'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      402: components['responses']['402PaymentRequired'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-registry-credential': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the registry credential */
        registryCredentialId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['registryCredential'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-registry-credential': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the registry credential */
        registryCredentialId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Registry credential deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-registry-credential': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the registry credential */
        registryCredentialId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          registry: components['schemas']['registryCredentialRegistry'];
          name: string;
          username: string;
          authToken: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['registryCredential'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      402: components['responses']['402PaymentRequired'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-services': {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /** @description Filter for types of services */
        type?: components['parameters']['serviceTypeParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /**
         * @deprecated
         * @description Filter for environments (runtimes) of services (deprecated; use `runtime` instead)
         */
        env?: components['parameters']['envParam'];
        /** @description Filter by resource region */
        region?: components['parameters']['regionParam'];
        /** @description Filter resources based on whether they're suspended or not suspended */
        suspended?: components['parameters']['suspendedParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Include previews in the response */
        includePreviews?: components['parameters']['includePreviewsParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['serviceList'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-service': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['servicePOST'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['serviceAndDeploy'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      402: components['responses']['402PaymentRequired'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['service'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['servicePATCH'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['service'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      402: components['responses']['402PaymentRequired'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'purge-cache': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        '*/*'?: never;
      };
    };
    responses: {
      /** @description Cache purge request accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-deploys': {
    parameters: {
      query?: {
        /** @description Filter for deploys with the specified statuses */
        status?: components['schemas']['deployStatus'][];
        /**
         * @description Filter for deploys created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: string;
        /**
         * @description Filter for deploys created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: string;
        /**
         * @description Filter for deploys updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: string;
        /**
         * @description Filter for deploys updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        updatedAfter?: string;
        /**
         * @description Filter for deploys finished before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        finishedBefore?: string;
        /**
         * @description Filter for deploys finished after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        finishedAfter?: string;
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['deployList'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-deploy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description If `clear`, Render clears the service's build cache before deploying. This can be useful if you're experiencing issues with your build.
           * @default do_not_clear
           * @enum {string}
           */
          clearCache?: 'clear' | 'do_not_clear';
          /**
           * @description The SHA of a specific Git commit to deploy for a service. Defaults to the latest commit on the service's connected branch.
           *
           *     Note that deploying a specific commit with this endpoint does not disable autodeploys for the service.
           *
           *     You can toggle autodeploys for your service with the [Update service](https://api-docs.render.com/reference/update-service) endpoint or in the Render Dashboard.
           *
           *     Not supported for cron jobs.
           */
          commitId?: string;
          /**
           * @description The URL of the image to deploy for an image-backed service.
           *
           *     The host, repository, and image name all must match the currently configured image for the service.
           */
          imageUrl?: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['deploy'];
        };
      };
      /** @description Queued */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-deploy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the deploy */
        deployId: components['parameters']['deployIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['deploy'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'cancel-deploy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the deploy */
        deployId: components['parameters']['deployIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['deploy'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'rollback-deploy': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @description The ID of the deploy to roll back to */
          deployId: string;
        };
      };
    };
    responses: {
      /** @description OK */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['deploy'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'get-env-vars-for-service': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envVarWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-env-vars-for-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['envVarInputArray'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envVarWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-env-var': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envVar'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-env-var': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['addUpdateEnvVarInput'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envVar'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-env-var': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Environment variable deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-secret-files-for-service': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['secretFileWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-secret-files-for-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['secretFileInput'][];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['secretFileWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-secret-file': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The file name of the secret file */
        secretFileName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['secretFile'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'add-or-update-secret-file': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The file name of the secret file */
        secretFileName: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          content?: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['secretFile'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-secret-file': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The file name of the secret file */
        secretFileName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Secret file deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-events': {
    parameters: {
      query?: {
        /** @description The type of event to filter to */
        type?: components['parameters']['eventTypeParam'];
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['serviceEventWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-headers': {
    parameters: {
      query?: {
        /** @description Filter for specific paths that headers apply to */
        path?: string[];
        /** @description Filter for header names */
        name?: string[];
        /** @description Filter for header values */
        value?: string[];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['headerWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-headers': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['headerInput'][];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['header'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'add-headers': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['headerInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            headers?: components['schemas']['header'];
          };
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-header': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The id of the header */
        headerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Header deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-routes': {
    parameters: {
      query?: {
        /** @description Filter for the type of route rule */
        type?: ('redirect' | 'rewrite')[];
        /** @description Filter for the source path of the route */
        source?: string[];
        /** @description Filter for the destination path of the route */
        destination?: string[];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['routeWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'put-routes': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['routePut'][];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['route'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'add-route': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['routePost'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['route'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'patch-route': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['routePatch'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            headers?: components['schemas']['route'];
          };
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-route': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The id of the route */
        routeId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Route deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-custom-domains': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
        /** @description Filter for the names of custom domain */
        name?: string[];
        /** @description Filter for domain type */
        domainType?: 'apex' | 'subdomain';
        /** @description Filter for domain verification status (`verified` or `unverified`) */
        verificationStatus?: 'verified' | 'unverified';
        /**
         * @description Filter for custom domains created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: string;
        /**
         * @description Filter for custom domains created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: string;
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['customDomainWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-custom-domain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          name: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['customDomain'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      402: components['responses']['402PaymentRequired'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      409: components['responses']['409Conflict'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-custom-domain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID or name of the custom domain */
        customDomainIdOrName: components['parameters']['customDomainIdOrNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['customDomain'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-custom-domain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID or name of the custom domain */
        customDomainIdOrName: components['parameters']['customDomainIdOrNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Custom domain deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'refresh-custom-domain': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID or name of the custom domain */
        customDomainIdOrName: components['parameters']['customDomainIdOrNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Custom domain verification triggered */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'suspend-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service suspended successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'resume-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service resumed successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'restart-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service restarted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'scale-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @example 3 */
          numInstances: number;
        };
      };
    };
    responses: {
      /** @description Service scaled successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'autoscale-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['autoscalingConfig'];
      };
    };
    responses: {
      /** @description Autoscaling configuration updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['autoscalingConfig'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-autoscaling-config': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Autoscaling config deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'preview-service': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['previewInput'];
      };
    };
    responses: {
      /** @description Created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['serviceAndDeploy'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-job': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
        /** @description Filter for the status of the job (`pending`, `running`, `succeeded`, `failed`, or `canceled`) */
        status?: components['schemas']['jobStatus'][];
        /**
         * @description Filter for jobs created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: string;
        /**
         * @description Filter for jobs created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: string;
        /**
         * @description Filter for jobs started before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        startedBefore?: string;
        /**
         * @description Filter for jobs started after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        startedAfter?: string;
        /**
         * @description Filter for jobs finished before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        finishedBefore?: string;
        /**
         * @description Filter for jobs finished after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        finishedAfter?: string;
      };
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['jobWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'post-job': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          startCommand: string;
          planId?: string;
        };
      };
    };
    responses: {
      /** @description OK */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['job'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-job': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the job */
        jobId: components['parameters']['jobId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['job'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'cancel-job': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
        /** @description The ID of the job */
        jobId: components['parameters']['jobId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['job'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-instances': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['serviceInstance'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'run-cron-job': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the cron job */
        cronJobId: components['parameters']['cronJobIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['cronJobRun'];
        };
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'cancel-cron-job-run': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the cron job */
        cronJobId: components['parameters']['cronJobIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cancelled */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      406: components['responses']['406NotAcceptable'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-event': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the event */
        eventId: components['schemas']['eventId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['event'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-logs': {
    parameters: {
      query: {
        /** @description The ID of the workspace to return logs for */
        ownerId: string;
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /**
         * @description The direction to query logs for. Backward will return most recent logs first.
         *     Forward will start with the oldest logs in the time range.
         */
        direction?: components['parameters']['logDirectionParam'];
        /** @description Filter logs by their resource. A resource is the id of a server, cronjob, job, postgres, redis, or workflow. */
        resource: components['parameters']['logFilterResource'];
        /** @description Filter logs by the instance they were emitted from. An instance is the id of a specific running server. */
        instance?: components['parameters']['logFilterInstance'];
        /** @description Filter request logs by their host. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        host?: components['parameters']['logFilterHost'];
        /** @description Filter request logs by their status code. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        statusCode?: components['parameters']['logFilterStatusCode'];
        /** @description Filter request logs by their requests method. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        method?: components['parameters']['logFilterMethod'];
        /** @description Filter logs by their task(s) */
        task?: components['parameters']['logFilterTask'];
        /** @description Filter logs by their task run id(s) */
        taskRun?: components['parameters']['logFilterTaskRun'];
        /** @description Filter logs by their severity level. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        level?: components['parameters']['logFilterLevel'];
        /** @description Filter logs by their type. Types include `app` for application logs, `request` for request logs, and `build` for build logs. You can find the full set of types available for a query by using the `GET /logs/values` endpoint. */
        type?: components['parameters']['logFilterType'];
        /** @description Filter by the text of the logs. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        text?: components['parameters']['logFilterText'];
        /** @description Filter request logs by their path. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        path?: components['parameters']['logFilterPath'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Logs200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'subscribe-logs': {
    parameters: {
      query: {
        /** @description The ID of the workspace to return logs for */
        ownerId: string;
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /**
         * @description The direction to query logs for. Backward will return most recent logs first.
         *     Forward will start with the oldest logs in the time range.
         */
        direction?: components['parameters']['logDirectionParam'];
        /** @description Filter logs by their resource. A resource is the id of a server, cronjob, job, postgres, redis, or workflow. */
        resource: components['parameters']['logFilterResource'];
        /** @description Filter logs by the instance they were emitted from. An instance is the id of a specific running server. */
        instance?: components['parameters']['logFilterInstance'];
        /** @description Filter request logs by their host. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        host?: components['parameters']['logFilterHost'];
        /** @description Filter request logs by their status code. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        statusCode?: components['parameters']['logFilterStatusCode'];
        /** @description Filter request logs by their requests method. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        method?: components['parameters']['logFilterMethod'];
        /** @description Filter logs by their task(s) */
        task?: components['parameters']['logFilterTask'];
        /** @description Filter logs by their task run id(s) */
        taskRun?: components['parameters']['logFilterTaskRun'];
        /** @description Filter logs by their severity level. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        level?: components['parameters']['logFilterLevel'];
        /** @description Filter logs by their type. Types include `app` for application logs, `request` for request logs, and `build` for build logs. You can find the full set of types available for a query by using the `GET /logs/values` endpoint. */
        type?: components['parameters']['logFilterType'];
        /** @description Filter by the text of the logs. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        text?: components['parameters']['logFilterText'];
        /** @description Filter request logs by their path. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        path?: components['parameters']['logFilterPath'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The connection has been upgraded to a websocket. The server will send log messages as they are generated in the format defined below. */
      101: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['log'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-logs-values': {
    parameters: {
      query: {
        /** @description The ID of the workspace to return log label values for */
        ownerId: string;
        /** @description The label to query logs for */
        label: components['parameters']['logLabelParam'];
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /**
         * @description The direction to query logs for. Backward will return most recent logs first.
         *     Forward will start with the oldest logs in the time range.
         */
        direction?: components['parameters']['logDirectionParam'];
        /** @description Filter logs by their resource. A resource is the id of a server, cronjob, job, postgres, redis, or workflow. */
        resource: components['parameters']['logFilterResource'];
        /** @description Filter logs by the instance they were emitted from. An instance is the id of a specific running server. */
        instance?: components['parameters']['logFilterInstance'];
        /** @description Filter request logs by their host. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        host?: components['parameters']['logFilterHost'];
        /** @description Filter request logs by their status code. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        statusCode?: components['parameters']['logFilterStatusCode'];
        /** @description Filter request logs by their requests method. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        method?: components['parameters']['logFilterMethod'];
        /** @description Filter logs by their task(s) */
        task?: components['parameters']['logFilterTask'];
        /** @description Filter logs by their task run id(s) */
        taskRun?: components['parameters']['logFilterTaskRun'];
        /** @description Filter logs by their severity level. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        level?: components['parameters']['logFilterLevel'];
        /** @description Filter logs by their type. Types include `app` for application logs, `request` for request logs, and `build` for build logs. You can find the full set of types available for a query by using the `GET /logs/values` endpoint. */
        type?: components['parameters']['logFilterType'];
        /** @description Filter by the text of the logs. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        text?: components['parameters']['logFilterText'];
        /** @description Filter request logs by their path. [Wildcards and regex](https://render.com/docs/logging#wildcards-and-regular-expressions) are supported. */
        path?: components['parameters']['logFilterPath'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['LogsValues200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'get-owner-log-stream': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return log stream information for */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetOwnerLogsStreams200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-owner-log-stream': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to update log stream information for */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['logStreamOwnerUpdate'];
      };
    };
    responses: {
      200: components['responses']['GetOwnerLogsStreams200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-owner-log-stream': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to delete the log stream for */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Log stream setting deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-resource-log-streams': {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter log streams by their id. */
        logStreamId?: components['parameters']['logStreamIdFilter'];
        /** @description IDs of resources (server, cron job, postgres, or redis) to filter by */
        resourceId?: components['parameters']['resourceIdParam'];
        /** @description Filter log streams by their setting. */
        setting?: components['parameters']['logStreamSettingFilter'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ResourceLogsStreams200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'get-resource-log-stream': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the resource (server, cron job, postgres, or redis) to return log stream override information for */
        resourceId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetResourceLogsStreams200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-resource-log-stream': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the resource (server, cron job, postgres, or redis) to update log stream override information for */
        resourceId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['logStreamResourceUpdate'];
      };
    };
    responses: {
      200: components['responses']['GetResourceLogsStreams200Response'];
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-resource-log-stream': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the resource (server, cron job, postgres, or redis) whose log streams should be returned */
        resourceId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Log stream setting deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  getOwnerMetricsStream: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return metrics stream information for */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetMetricsStream200Response'];
      400: components['responses']['400BadRequest'];
      /** @description metrics stream not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      500: components['responses']['500InternalServerError'];
    };
  };
  upsertOwnerMetricsStream: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return metrics stream information for */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['metricsStreamInput'];
      };
    };
    responses: {
      /** @description metrics stream successfully updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['metricsStream'];
        };
      };
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  deleteOwnerMetricsStream: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workspace to return metrics stream information for */
        ownerId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description metrics stream integration deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      /** @description metrics stream not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-cpu': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
        /** @description The aggregation method to apply to multiple time series */
        aggregationMethod?: components['parameters']['applicationMetricAggregationMethod'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-cpu-limit': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-cpu-target': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-memory': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-memory-limit': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-memory-target': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description Instance ID to query. When multiple instance ID query params are provided, they are ORed together */
        instance?: components['parameters']['instanceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-http-requests': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
        path?: components['parameters']['pathQueryParam'];
        /** @description The field to aggregate by */
        aggregateBy?: components['parameters']['httpAggregateBy'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-http-latency': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
        path?: components['parameters']['pathQueryParam'];
        /** @description The quantile of latencies to fetch. When multiple quantile query params are provided, they are ORed together */
        quantile?: components['parameters']['quantile'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-bandwidth': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-bandwidth-sources': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response with traffic source breakdown */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "data": [
           *         {
           *           "labels": {
           *             "resource": "srv-abc123",
           *             "trafficSource": "total"
           *           },
           *           "values": [
           *             {
           *               "timestamp": 1709856000,
           *               "value": 125.5
           *             },
           *             {
           *               "timestamp": 1709859600,
           *               "value": 98.2
           *             }
           *           ]
           *         },
           *         {
           *           "labels": {
           *             "resource": "srv-abc123",
           *             "trafficSource": "http"
           *           },
           *           "values": [
           *             {
           *               "timestamp": 1709856000,
           *               "value": 100
           *             },
           *             {
           *               "timestamp": 1709859600,
           *               "value": 75.8
           *             }
           *           ]
           *         },
           *         {
           *           "labels": {
           *             "resource": "srv-abc123",
           *             "trafficSource": "websocket"
           *           },
           *           "values": [
           *             {
           *               "timestamp": 1709856000,
           *               "value": 25.5
           *             },
           *             {
           *               "timestamp": 1709859600,
           *               "value": 22.4
           *             }
           *           ]
           *         }
           *       ]
           *     }
           */
          'application/json': {
            data?: {
              labels?: {
                /** @example srv-abc123 */
                resource?: string;
                /**
                 * @example http
                 * @enum {string}
                 */
                trafficSource?: 'total' | 'http' | 'websocket' | 'nat' | 'privatelink';
              };
              values?: {
                /** @example 1709856000 */
                timestamp?: number;
                /** @example 100 */
                value?: number;
              }[];
            }[];
          };
        };
      };
      /** @description Bad request - invalid date range */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @example bandwidth sources data is only available after 2025-03-09 */
            error?: string;
          };
        };
      };
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-disk-usage': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-disk-capacity': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-instance-count': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources can be service ids, Postgres ids, or Redis ids */
        resource?: components['parameters']['resourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-active-connections': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Resource ID to query. When multiple resource query params are provided, they are ORed together. Resources Postgres ids or Redis ids */
        resource?: components['parameters']['datastoreResourceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'get-replication-lag': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Postgres ID to query. When multiple resource query params are provided, they are ORed together */
        resource?: components['parameters']['postgresResourceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['Metrics200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'list-application-filter-values': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MetricsFiltersApplication200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'list-http-filter-values': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The status codes of HTTP requests to filter to. When multiple status code query params are provided, they are ORed together */
        statusCode?: components['parameters']['httpStatusCode'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MetricsFiltersHTTP200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'list-path-filter-values': {
    parameters: {
      query?: {
        /** @description Epoch/Unix timestamp of start of time range to return. Defaults to `now() - 1 hour`. */
        startTime?: components['parameters']['startTimeParam'];
        /** @description Epoch/Unix timestamp of end of time range to return. Defaults to `now()`. */
        endTime?: components['parameters']['endTimeParam'];
        /** @description The resolution of the returned data */
        resolutionSeconds?: components['parameters']['resolutionParam'];
        /** @description Service ID to query. When multiple service ids are provided, they are ORed together */
        resource?: components['parameters']['serviceResourceQueryParam'];
        /**
         * @deprecated
         * @description This parameter is deprecated. Please use `resource` instead
         */
        service?: components['parameters']['serviceQueryParam'];
        /** @description The hosts of HTTP requests to filter to. When multiple host query params are provided, they are ORed together */
        host?: components['parameters']['hostQueryParam'];
        /** @description The status codes of HTTP requests to filter to. When multiple status code query params are provided, they are ORed together */
        statusCode?: components['parameters']['httpStatusCode'];
        /** @description The paths of HTTP requests to filter to. When multiple path query params are provided, they are ORed together */
        path?: components['parameters']['pathQueryParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MetricsFiltersPath200Response'];
      400: components['responses']['400BadRequest'];
      500: components['responses']['500InternalServerError'];
    };
  };
  'list-key-value': {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /** @description Filter by resource region */
        region?: components['parameters']['regionParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['keyValueWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-key-value': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['keyValuePOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['keyValueDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-key-value': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        keyValueId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['keyValueDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-key-value': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        keyValueId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Key Value instance deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-key-value': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        keyValueId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['keyValuePATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['keyValueDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-key-value-connection-info': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        keyValueId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['keyValueConnectionInfo'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-redis': {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /** @description Filter by resource region */
        region?: components['parameters']['regionParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['redisWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-redis': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['redisPOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['redisDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-redis': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        redisId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['redisDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-redis': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        redisId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Redis instance deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-redis': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        redisId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['redisPATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['redisDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-redis-connection-info': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        redisId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['redisConnectionInfo'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-postgres': {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /** @description Filter by resource region */
        region?: components['parameters']['regionParam'];
        /** @description Filter resources based on whether they're suspended or not suspended */
        suspended?: components['parameters']['suspendedParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /** @description Include replicas in the response */
        includeReplicas?: components['parameters']['includeReplicasParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['postgresPOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Postgres instance deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['postgresPATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      409: components['responses']['409Conflict'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-postgres-connection-info': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresConnectionInfo'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-postgres-recovery-info': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['recoveryInfo'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'recover-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['recoveryInput'];
      };
    };
    responses: {
      /** @description Recovery initiated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresDetail'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'suspend-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service suspended successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'resume-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service resumed successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'restart-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service restarted successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'failover-postgres': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service failed over successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-postgres-export': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['postgresExport'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-postgres-export': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        postgresId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Export started successfully */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      406: components['responses']['406NotAcceptable'];
      410: components['responses']['410Gone'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-projects': {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['projectWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-project': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['projectPOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['project'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-project': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        projectId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['project'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-project': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        projectId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Project deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-project': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        projectId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['projectPATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['project'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-environments': {
    parameters: {
      query: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /** @description Filter for resources that belong to a project */
        projectId: components['parameters']['projectIdParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['environmentWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-environment': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['environmentPOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['environment'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-environment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        environmentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['environment'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-environment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        environmentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Environment deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-environment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        environmentId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['environmentPATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['environment'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'add-resources-to-environment': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        environmentId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['environmentResourcesPOSTInput'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['environment'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'remove-resources-from-environment': {
    parameters: {
      query: {
        resourceIds: string[];
      };
      header?: never;
      path: {
        environmentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Resources removed from environment */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-env-groups': {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /**
         * @description Filter for resources created before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        createdBefore?: components['parameters']['createdBeforeParam'];
        /**
         * @description Filter for resources created after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        createdAfter?: components['parameters']['createdAfterParam'];
        /**
         * @description Filter for resources updated before a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedBefore?: components['parameters']['updatedBeforeParam'];
        /**
         * @description Filter for resources updated after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        updatedAfter?: components['parameters']['updatedAfterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroupMeta'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-env-group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['envGroupPOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroup'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-env-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Filter for resources that belong to an environment group */
        envGroupId: components['parameters']['envGroupIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroup'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-env-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        envGroupId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description environment group deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-env-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        envGroupId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['envGroupPATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroup'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'link-service-to-env-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Filter for resources that belong to an environment group */
        envGroupId: components['parameters']['envGroupIdParam'];
        /** @description The ID of the service */
        serviceId: components['parameters']['serviceIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroup'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'unlink-service-from-env-group': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        envGroupId: string;
        serviceId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description service unlinked from environment group */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-env-group-env-var': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Filter for resources that belong to an environment group */
        envGroupId: components['parameters']['envGroupIdParam'];
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envVar'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-env-group-env-var': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Filter for resources that belong to an environment group */
        envGroupId: components['parameters']['envGroupIdParam'];
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['addUpdateEnvVarInput'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroup'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-env-group-env-var': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        envGroupId: string;
        /** @description The name of the environment variable */
        envVarKey: components['parameters']['envVarKeyParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description environment variable removed from environment group */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-env-group-secret-file': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Filter for resources that belong to an environment group */
        envGroupId: components['parameters']['envGroupIdParam'];
        /** @description The name of the secret file */
        secretFileName: components['parameters']['secretFileNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['secretFile'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-env-group-secret-file': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        envGroupId: string;
        secretFileName: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          content?: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['envGroup'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-env-group-secret-file': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Filter for resources that belong to an environment group */
        envGroupId: components['parameters']['envGroupIdParam'];
        /** @description The name of the secret file */
        secretFileName: components['parameters']['secretFileNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description secret file removed from environment group */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-maintenance': {
    parameters: {
      query?: {
        resourceId?: components['parameters']['maintenanceResourcesParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        state?: components['parameters']['maintenanceStateParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['maintenanceRunWithResource'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-maintenance': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        maintenanceRunParam: components['parameters']['maintenanceRunParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['maintenanceRunWithResource'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-maintenance': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        maintenanceRunParam: components['parameters']['maintenanceRunParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['maintenanceRunPATCH'];
      };
    };
    responses: {
      /** @description Maintenance run updated */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'trigger-maintenance': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        maintenanceRunParam: components['parameters']['maintenanceRunParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Maintenance run triggered */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-webhooks': {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['webhookWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'create-webhook': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['webhookPOSTInput'];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['webhook'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'retrieve-webhook': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the webhook */
        webhookId: components['parameters']['webhookIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['webhook'];
        };
      };
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'delete-webhook': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the webhook */
        webhookId: components['parameters']['webhookIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Webhook deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'update-webhook': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the webhook */
        webhookId: components['parameters']['webhookIdParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['webhookPATCHInput'];
      };
    };
    responses: {
      /** @description Updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['webhook'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  'list-webhook-events': {
    parameters: {
      query?: {
        /**
         * @description Filter events sent before this time (specified as an ISO 8601 timestamp)
         * @example 2021-06-17T08:15:30Z
         */
        sentBefore?: components['parameters']['sentBeforeParam'];
        /**
         * @description Filter for resources sent after a certain time (specified as an ISO 8601 timestamp)
         * @example 2021-02-17T08:15:30Z
         */
        sentAfter?: components['parameters']['sentAfterParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
      };
      header?: never;
      path: {
        /** @description Unique identifier for the webhook */
        webhookId: components['parameters']['webhookIdParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['webhookEventWithCursor'][];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  listWorkflows: {
    parameters: {
      query?: {
        /** @description Filter by name */
        name?: components['parameters']['nameParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description The IDs of the workflows to return resources for */
        workflowID?: components['parameters']['workflowIdParam'];
        /** @description Filter for resources that belong to an environment */
        environmentId?: components['parameters']['environmentIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of workflows */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['workflowWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  createWorkflow: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkflowCreate'];
      };
    };
    responses: {
      /** @description Workflow created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Workflow'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  getWorkflow: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workflow */
        workflowId: components['parameters']['WorkflowIDParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Workflow'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  deleteWorkflow: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workflow */
        workflowId: components['parameters']['WorkflowIDParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  updateWorkflow: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workflow */
        workflowId: components['parameters']['WorkflowIDParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkflowUpdate'];
      };
    };
    responses: {
      /** @description Workflow updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Workflow'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  listWorkflowVersions: {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description The IDs of the workflows to return resources for */
        workflowID?: components['parameters']['workflowIdParam'];
        /** @description The IDs of the workflow versions to return resources for */
        workflowVersionId?: components['parameters']['workflowVersionIdParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of workflow versions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['workflowVersionWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  createWorkflowVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateVersion'];
      };
    };
    responses: {
      /** @description Workflow version created */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  getWorkflowVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the workflow version */
        workflowVersionId: components['parameters']['WorkflowVersionIDParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow version details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowVersion'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  listTasks: {
    parameters: {
      query?: {
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /**
         * @description An array of either task identifiers which can be either a task ID or a workflow slug with task name and optional version. If a version is not provided, the latest version of the task will be used.
         * @example [
         *       "tsk-1234",
         *       "my-workflow-slug/my-task",
         *       "my-workflow-slug/my-task:SHA123"
         *     ]
         */
        taskId?: components['parameters']['TaskIdFilterParam'];
        /** @description An array of workflow version IDs */
        workflowVersionId?: components['parameters']['WorkflowVersionIDFilterParam'];
        /** @description An array of workflow IDs */
        workflowId?: components['parameters']['WorkflowIDFilterParam'];
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of tasks */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['taskWithCursor'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  getTask: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the task */
        taskId: components['parameters']['TaskIDParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Task details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Task'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  listTaskRuns: {
    parameters: {
      query?: {
        /** @description The position in the result list to start from when fetching paginated results. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        cursor?: components['parameters']['cursorParam'];
        /** @description The maximum number of items to return. For details, see [Pagination](https://api-docs.render.com/reference/pagination). */
        limit?: components['parameters']['limitParam'];
        /**
         * @description An array of either task identifiers which can be either a task ID or a workflow slug with task name and optional version. If a version is not provided, the latest version of the task will be used.
         * @example [
         *       "tsk-1234",
         *       "my-workflow-slug/my-task",
         *       "my-workflow-slug/my-task:SHA123"
         *     ]
         */
        taskId?: components['parameters']['TaskIdFilterParam'];
        /** @description An array of root task IDs to filter on */
        rootTaskRunId?: components['parameters']['RootTaskRunIDFilterParam'];
        /** @description The ID of the workspaces to return resources for */
        ownerId?: components['parameters']['ownerIdParam'];
        /** @description An array of workflow version IDs */
        workflowVersionId?: components['parameters']['WorkflowVersionIDFilterParam'];
        /** @description An array of workflow IDs */
        workflowId?: components['parameters']['WorkflowIDFilterParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of task runs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TaskRun'][];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  createTask: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunTask'];
      };
    };
    responses: {
      /** @description Task run created */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TaskRun'];
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  streamTaskRunsEvents: {
    parameters: {
      query: {
        /** @description Filter to a subset of task run IDs. */
        taskRunIds: string[];
      };
      header?: {
        /** @description Must be `text/event-stream`. */
        Accept?: 'text/event-stream';
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Event stream established */
      200: {
        headers: {
          /** @description Always `text/event-stream; charset=utf-8` */
          'Content-Type'?: string;
          /** @description SSE responses should be non-cacheable. */
          'Cache-Control'?: string;
          /** @description Keep-alive for streaming. */
          Connection?: string;
          [name: string]: unknown;
        };
        content: {
          'text/event-stream': string;
        };
      };
      400: components['responses']['400BadRequest'];
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  getTaskRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the task run */
        taskRunId: components['parameters']['TaskRunIDParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Task run details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TaskRunDetails'];
        };
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
  cancelTaskRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the task run */
        taskRunId: components['parameters']['TaskRunIDParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Task run canceled */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['401Unauthorized'];
      403: components['responses']['403Forbidden'];
      404: components['responses']['404NotFound'];
      429: components['responses']['429RateLimit'];
      500: components['responses']['500InternalServerError'];
      503: components['responses']['503ServiceUnavailable'];
    };
  };
}
